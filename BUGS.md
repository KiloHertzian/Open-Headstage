# Known Issues & Development Status

This document tracks known bugs, limitations, and the overall development status of the Open Headstage project.

---

*There are no known critical bugs at this time.*

---

## Resolved Issues & Lessons Learned

### Rust 2024 Edition Upgrade with `bindgen` (Resolved)

*   **Original Problem:** The upgrade to the Rust 2024 edition failed with compilation errors stating `extern blocks must be unsafe`. The errors originated from the FFI bindings file generated by the `bindgen` crate in `build.rs`.
*   **Root Cause Analysis:** The Rust 2024 edition enforces that all `extern "C" { ... }` blocks, which define foreign function interfaces, must be explicitly marked as `unsafe`. The `bindgen` configuration in our `build.rs` file was using a `.raw_line()` to manually inject a function definition, and this manually written line did not include the `unsafe` keyword. The standard `cargo fix --edition` tool did not automatically fix this because it was a string literal inside the build script, not source code it was analyzing directly.
*   **Resolution:**
    1.  The `bindgen` dependency in `Cargo.toml` was updated to a newer version as a first step, though this did not resolve the issue on its own.
    2.  The core of the fix was to modify the `.raw_line()` call in `build.rs` to prepend `unsafe` to the `extern "C"` block string.
*   **Lesson Learned:**
    1.  **`cargo fix` has limits:** The `cargo fix --edition` tool is powerful but cannot fix everything. It does not parse string literals in build scripts. Manually generated code, especially via `raw_line` in `build.rs`, must be audited and updated by hand during an edition migration.
    2.  **Build Scripts are Source Code:** The build script (`build.rs`) is a critical part of the compilation process and is subject to the same language rules and changes as the rest of the codebase. When a new edition introduces new requirements (like `unsafe extern`), build scripts must also be updated to comply.
    3.  **Isolate the Source:** The compiler error clearly pointed to the generated `mysofa_bindings.rs` file in the `target` directory. This was the key clue that the problem was not in the application source code (`src/...`) but in the code *generation* step, leading directly to an inspection of `build.rs`.

### Environment/Toolchain Incompatibility with `nih-plug` (Resolved)

*   **Original Problem:** The project failed to build in the CI environment because the available Rust compiler (1.75.0) was too old for the version of `nih-plug` being used, which required Rust 1.80+. Attempts to pin `nih-plug` to an older version failed due to git fetching errors in the CI.
*   **Resolution:** The CI environment's Rust toolchain was updated to a newer version (1.87.0). This immediately resolved the compilation failures.
*   **Lesson Learned:**
    1.  **Toolchain is Key:** The Rust compiler version is a critical dependency, especially when using cutting-edge libraries that pull from git repositories.
    2.  **CI Configuration:** The `rust-toolchain` file or the CI workflow script (`.github/workflows/rust_ci.yml`) is the canonical source for the required Rust version and must be kept in sync with the project's needs.
    3.  **Clear Error Messages:** The final build success was only possible after getting clear error messages. When builds fail, identifying the root cause (e.g., compiler version vs. code error) is the most important step.

### Cargo Feature Resolution for UI Dependencies (Resolved)

*   **Original Problem:** The project failed to compile with persistent errors related to `nih-plug` features, specifically the `gui` feature. The error message "the package `open-headstage` depends on `nih_plug`, with features: `gui` but `nih_plug` does not have these features" was misleading and caused a series of incorrect fix attempts, including using local path dependencies which introduced workspace conflicts.
*   **Resolution:**
    1.  The local `nih-plug` repository clone was removed to eliminate path and workspace conflicts.
    2.  The `Cargo.toml` dependencies for `nih_plug` and `nih_plug_egui` were changed from local paths to specific versions from `crates.io`.
    3.  The `gui` feature was correctly enabled directly on the `nih_plug` dependency line in `Cargo.toml`: `nih_plug = { version = "0.5.1", features = ["gui"] }`.
    4.  The `ui` feature in the local `[features]` section was corrected to only include the optional UI-specific crates: `ui = ["nih_plug_egui", "rfd"]`.
*   **Lesson Learned:**
    1.  **`crates.io` is the Source of Truth:** When facing intractable dependency or feature issues with a local git checkout, revert to a stable version from `crates.io`. This simplifies the build environment and eliminates potential inconsistencies in the local repository's `Cargo.toml`.
    2.  **Enabling Dependency Features:** To enable a feature for a dependency, it **must** be done on the dependency's line in `Cargo.toml`. The `[features]` section of the current crate is for defining its *own* features, which can then be used to conditionally enable dependencies or code via `cfg` attributes. The two are not interchangeable.
    3.  **Deconstruct the Error:** The error message was confusing. While it said `nih_plug` didn't have the `gui` feature, the real issue was the complex interaction of local paths, workspace conflicts, and an incorrectly defined local feature. Simplifying the situation (by removing the local path) was key to revealing the true, much simpler, solution.

### `nih-plug` Parameter System & Threading (Resolved)

*   **Original Problem:** A series of compilation errors arose from a misunderstanding of the `nih-plug` parameter system and thread-safety requirements.
    *   `StringParam` was used for the SOFA file path, but this parameter type does not exist in the current version of `nih-plug`.
    *   The `task_executor` function signature was incorrect, causing ownership and lifetime errors when trying to share plugin state (`MySofa`, `ConvolutionEngine`) with the background thread.
    *   Attempts to `Clone` `MySofa` failed because it contains a raw pointer and is not designed to be cloned.
*   **Resolution:**
    1.  **Replaced `StringParam`:** The non-existent `StringParam` was replaced with a `#[persist]` field: `pub sofa_file_path: Arc<RwLock<String>>`. This correctly handles persistent, non-parameter state.
    2.  **Corrected Thread Safety:** To safely share state between the audio processor, the UI, and the background task executor, `Arc<RwLock<>>` (for the SOFA path string) and `Arc<Mutex<>>` (for the `MySofa` loader) were used. This ensures safe interior mutability across threads.
    3.  **Fixed `task_executor`:** The `task_executor` was corrected to return a closure that captures the necessary thread-safe state (`Arc`-wrapped handles), resolving the ownership issues.
    4.  **Made `ConvolutionEngine` Clonable:** The `ConvolutionEngine` struct was made clonable (`#[derive(Clone)]`) to allow it to be moved into the background closure, although this was later refacored to avoid unnecessary cloning.
*   **Lesson Learned:**
    1.  **Parameters vs. Persistent State:** Use `nih-plug`'s `Param` types (`FloatParam`, etc.) only for values that are automated and controlled by the host. For other state that needs to be saved, like file paths or editor state, use `#[persist]` on a thread-safe container like an `Arc<RwLock<T>>`.
    2.  **Threading is Explicit:** When sharing state between the UI/background threads and the real-time audio thread, standard Rust thread-safety patterns (`Arc`, `Mutex`, `RwLock`) are required. The plugin's main struct fields must be designed for this from the start if they are to be shared.
    3.  **Consult the Source:** When a type or feature seems to be missing or causes confusing errors, the quickest path to a solution is to inspect the library's source code (`src/params.rs` in this case) to see the available types and their intended usage. `grep` is an invaluable tool for this.
    4.  **Compiler Errors Guide Architecture:** The series of ownership, lifetime, and      trait implementation errors were not just syntax problems; they were pointing to a          fundamental architectural issue in how state was being shared. Resolving them required      changing the data structures themselves, not just the function calls.

### CI Build Failures due to Missing System Dependencies (Resolved)

*   **Original Problem:** After successfully compiling locally, the CI build failed repeatedly with `pkg-config` errors. The build script could not find system libraries required by the GUI toolkit, such as `glib-2.0`, `atk`, and `gdk-3.0`.
*   **Resolution:** The issue was resolved by adding the main GTK3 development meta-package, `libgtk-3-dev`, to the `apt-get install` command in the `.github/workflows/rust_ci.yml` file. This single package automatically pulled in all the necessary dependencies (`glib`, `atk`, `gdk`, `pango`, etc.) that the UI crates rely on.
*   **Lesson Learned:**
    1.  **Install Comprehensive Dev Packages:** When dealing with large C/C++-based libraries or toolkits like GTK, it is more robust to install the primary development package (e.g., `libgtk-3-dev`) rather than trying to install each required sub-library individually. This avoids a "whack-a-mole" scenario where fixing one missing dependency reveals another.
    2.  **Local vs. CI Environments:** A successful local build does not guarantee a successful CI build. The CI environment is clean and will expose any missing system dependencies that might already be installed on a local development machine. The CI configuration must be treated as the canonical list of build requirements.

### GUI File Dialog Failures (Crash on Click)

*   **Original Problem:** The plugin, when loaded in a Qt-based host like Carla, would crash instantly upon clicking the "Select SOFA File" button.
*   **Root Cause Analysis:** The crash was caused by using the `rfd` (Rust File Dialog) crate directly within the plugin's GUI. `rfd` attempts to open a native GTK file dialog, which conflicts with the host's Qt event loop, leading to a segmentation fault. This is a fundamental incompatibility between GUI toolkits.
*   **Failed Solutions & Lessons:**
    1.  **Incorrect API Usage:** An attempt to use `nih-plug`'s host-based file dialogs failed because of incorrect API knowledge. The methods I tried to call (`show_open_dialog`, `show_file_dialog` on `AsyncExecutor`) do not exist. **Lesson:** The `nih-plug` book and official examples are the only reliable source for API usage. Do not guess or assume.
    2.  **Dependency Version Hell:** An attempt to use the `egui-file-dialog` crate failed due to a cascade of dependency version conflicts. The version of `egui-file-dialog` used an older version of `egui` than `nih-plug-egui` did, leading to dozens of compiler errors. **Lesson:** The `nih-plug` ecosystem is very sensitive to dependency versions. Before adding any new `egui`-related crate, use `cargo tree` to verify that it uses the *exact same version* of `egui` as `nih-plug-egui`. If not, it is incompatible.
    3.  **Misunderstanding of State vs. Parameters:** An attempt to change the file path from a persistent `Arc<RwLock<String>>` to a `StringParam` was incorrect. **Lesson:** As documented previously, `Param` types are for host-automatable values. Simple persistent state that is not automatable should use the `#[persist]` attribute on a standard thread-safe type.
*   **Final Lesson:** GUI integrations are a major source of complexity and failure. The path forward requires a slow, careful, example-driven approach. The immediate problem (the crash) is resolved by removing the call to `rfd`, but a robust file dialog solution will require finding a compatible version of `egui-file-dialog` or writing a custom implementation that respects the `nih-plug` architecture.

### `egui` Dependency Version Conflict (Resolved)

*   **Original Problem:** After deciding to use `egui-file-dialog`, the build failed with dozens of errors related to mismatched types and missing methods. The root cause was a dependency conflict: `nih-plug` (from git) used `egui` v0.31.1, while the chosen version of `egui-file-dialog` (v0.5.0) used `egui` v0.27.2.
*   **Resolution:**
    1.  Used `cargo tree` to explicitly identify the two conflicting `egui` versions.
    2.  Used web search to browse the `egui-file-dialog` repository and its `Cargo.toml` files for different tagged versions.
    3.  Identified that `egui-file-dialog` v0.10.0 depends on `egui` v0.31.0, which is compatible with `nih-plug`'s requirement.
    4.  Updated `Cargo.toml` to use this specific compatible version.
*   **Lesson Learned:**
    1.  **`cargo tree` is Essential:** For any dependency-related issue, especially in a complex ecosystem like `egui`, `cargo tree` is the first and most important diagnostic tool. It makes version conflicts immediately obvious.
    2.  **Manual Version Vetting:** When depending on libraries from git, you cannot rely on `crates.io`'s automatic semantic versioning. You must manually check the `Cargo.toml` of the git dependency to find its exact requirements, and then find compatible versions of any related libraries you wish to add.
    3.  **Check the Source:** The `Cargo.toml` of a crate is the ultimate source of truth for its dependencies. Browsing the file for specific tags in the git repository is a reliable way to find compatible versions.

### VST3 Bundling Failure (Resolved)

*   **Original Problem:** The VST3 plugin was not being generated by `cargo build` and was not loading in Carla, even though the CLAP plugin passed validation. The `cargo xtask bundle` command, which is the standard `nih-plug` way to create bundles, was also failing silently.
*   **Resolution:**
    1.  Created a `bundler.toml` file with the required metadata for the plugin. This did not fix the `xtask` issue.
    2.  Bypassed the `xtask` system entirely and created the VST3 bundle manually by creating the `.vst3` directory structure and copying the compiled `.so` file into it.
*   **Lesson Learned:**
    1.  **`xtask` is not guaranteed:** The `cargo xtask` system is a convention, not a requirement. If it fails, it may be due to subtle configuration or versioning issues.
    2.  **Manual Bundling is a Viable Alternative:** The VST3 and CLAP formats are just specific directory structures. Understanding this allows for manual creation of the bundles, which is a robust fallback when the automated tooling fails.
    3.  **Isolate the Problem:** The `clap-validator` tool was critical in proving that the core plugin code was correct, which allowed me to focus on the VST3 packaging as the source of the problem.

### Architectural Misunderstanding of `nih-plug` Testing & Benchmarking (Resolved)

*   **Original Problem:** All attempts to create a `criterion`-based benchmark for the plugin's `process()` function failed with compilation errors. The errors indicated that the testing utility functions being used (`create_test_plugin`, `create_test_buffer`) did not exist and that core structs like `AuxiliaryBuffers` could not be instantiated.
*   **Root Cause Analysis:** The attempts were based on a fundamental misunderstanding of the `nih-plug` testing philosophy. I was assuming a conventional, in-process unit testing model where the test code is responsible for mocking a host environment and creating test objects. This is incorrect. The `nih-plug` framework has evolved to a higher-fidelity, out-of-process integration testing model.
*   **The Correct Paradigm (Standalone Execution):**
    1.  The canonical way to test, debug, and benchmark a `nih-plug` plugin is to compile it as a standalone application.
    2.  This is enabled by the `standalone` feature flag in `Cargo.toml` and the `nih_export_standalone()` macro.
    3.  This standalone application acts as a minimal host that connects to a real audio backend like the JACK Audio Connection Kit.
    4.  In this model, the developer does not create mock `Buffer` or `AuxiliaryBuffers` objects. Instead, the plugin *receives* real buffers from the JACK server via the standalone host wrapper.
*   **Resolution:** The problem was resolved by abandoning the flawed in-process benchmark attempt and adopting the standalone execution model. A new research document, `docs/research/Benchmarking-nih-plug.md`, was created to document this correct paradigm.
*   **Lesson Learned:**
    1.  **Verify the Paradigm, Not Just the API:** Before trying to use a framework's API, first understand its underlying philosophy and architecture. My focus on finding specific functions led me astray because the entire paradigm I was assuming was wrong.
    2.  **The `standalone` Feature is the Key to Testing:** The `standalone` feature is not merely for convenience; it is the entry point to the entire testing, debugging, and profiling workflow for `nih-plug`.
    3.  **Trust the Source, Not Outdated Docs:** The discrepancy arose from relying on outdated information. A forensic analysis of the current `master` branch source code was the only way to uncover the truth. The official, bundled examples are the most reliable source of current best practices.
    4.  **If It Feels Too Hard, You're Probably Doing It Wrong:** The immense difficulty I had trying to manually construct test objects was a signal that I was fighting the framework's design. The canonical method is much simpler because it delegates the hard work to the framework and the JACK server.

### Standalone Build Failure due to `crate-type` (Resolved)

*   **Original Problem:** After correctly configuring the project to build a standalone executable (`src/main.rs`), the build repeatedly failed with an `unresolved import` error. The binary crate (`main.rs`) was unable to find the library crate (`lib.rs`), even though the `use` statement (`use open_headstage::...`) was correct according to the hyphen-to-underscore rule.
*   **Root Cause Analysis:** The `Cargo.toml` file contained a `[lib]` section that explicitly set the library's `crate-type` to `["cdylib"]`. This instruction tells `rustc` to *only* compile the library as a C-style dynamic library, which is suitable for being loaded by a plugin host. However, it prevents the compiler from also generating the standard Rust library file (`.rlib`) that is required for other Rust crates (like our `main.rs` binary) to link against it. The binary had no library file to link to, causing the "unresolved import" error at the linking stage.
*   **Resolution:** The `crate-type` in `Cargo.toml` was modified to `["cdylib", "rlib"]`. This instructs Cargo to produce *both* the C-dynamic library for plugin hosts and the Rust library for other Rust crates.
*   **Lesson Learned:**
    1.  **`crate-type` is a Critical Override:** Explicitly setting `crate-type` in `Cargo.toml` completely overrides the default build outputs. If you need to link a Rust binary against your library (for testing, standalone executables, etc.), you **must** include `"rlib"` in the `crate-type` array.
    2.  **The Build System is the Final Arbiter:** When source code appears correct but linking fails, the issue is almost certainly in the build configuration (`Cargo.toml`). The "unresolved import" error, in this case, was a symptom of a linking failure, not a module path error.
    3.  **Follow the Checklist:** This issue was the final, most obscure item on the troubleshooting checklist from the `Rust Import Error Deep Dive.md` document. A systematic, step-by-step diagnosis is essential for solving complex build problems.

### Strategic Project Phasing & Planning

*   **Original Problem:** The project's `TODO.md` was structured chronologically based on when ideas were added, not by strategic priority. This led to a plan where complex, low-level DSP work was scheduled before high-value, user-facing features that could be implemented with existing code.
*   **Resolution:** The `TODO.md` was completely re-ordered into a more logical sequence.
    1.  **Legal & Licensing:** Moved to the beginning to de-risk the project early.
    2.  **High-Value Features (AutoEQ):** Prioritized to deliver maximum user value with minimal new engineering.
    3.  **Complex Core Features (Advanced EQ):** Grouped together into a dedicated phase.
    4.  **Optimization:** Moved to the end, as it should be done after all features are implemented.
*   **Lesson Learned:**
    1.  **Prioritize by Value vs. Effort:** The most effective project plan prioritizes tasks that deliver the highest user value for the lowest implementation effort. The AutoEQ integration is a perfect example of this.
    2.  **Foundation First:** Foundational, risk-reducing tasks like legal review and license management should be addressed early, even if they aren't user-facing features.
    3.  **Regularly Re-evaluate the Plan:** A project plan is a living document. It should be reviewed and re-prioritized regularly to adapt to new information, completed tasks, and a better understanding of the remaining work.

### Strategic Licensing & The "Open Core" Model

*   **Situation:** The project initially aimed to support the VST3 plugin format. A routine dependency audit revealed that the `vst3-sys` crate is licensed under `GPLv3` due to the VST3 SDK's own licensing terms. This created a direct conflict with the goal of maintaining long-term flexibility and the potential for future commercialization.

*   **Lesson Learned 1: Plugin format dictates the project's license.** The choice to support a specific plugin format is not just a technical decision but a critical legal one. The VST3 SDK's GPLv3 license option forces any open-source project using it to adopt the GPLv3 license as well. This "copyleft" nature must be evaluated at the very beginning of a project, as it has profound implications for all future development and distribution.

*   **Lesson Learned 2: Prioritize permissive licenses for future flexibility.** For a project that may have future commercial ambitions (even uncertain ones), a permissive license (like Apache-2.0 or MIT) is the superior choice. It allows the copyright holder to re-license the code for commercial products later. A copyleft license like GPLv3 permanently closes this door. We specifically chose **Apache-2.0** over MIT for its explicit patent grant clause, which offers stronger protection against patent-related lawsuits for both the project and its users.

*   **Lesson Learned 3: The "Open Core" model requires a CLA.** The strategy to balance a free, open-source project with future proprietary modules is the "Open Core" model. The key legal tool to enable this is a **Contributor License Agreement (CLA)**. A CLA ensures that the project owner retains full rights to re-license all contributed code, which is essential for creating a commercial version without needing to get permission from every past contributor.