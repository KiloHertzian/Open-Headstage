// Copyright 2025 SignalVerse
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crossbeam_channel::{Receiver, Sender};
use nih_plug::prelude::*;
use nih_plug_egui::{EguiState, create_egui_editor, egui, widgets};
use parking_lot::{Mutex, RwLock};
use serde::{Deserialize, Serialize};
use serde_json;
use std::env;
use std::fs;
use std::path::PathBuf;
use std::process::Command;
use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};
use std::time::{Duration, Instant};
use strum::{Display, EnumIter, IntoEnumIterator};

// Make sure our modules are declared
mod autoeq_parser;
mod dsp;
mod sofa;
mod ui;

use crate::autoeq_parser::{AutoEqProfile, BandSetting, parse_autoeq_file};
use crate::dsp::convolution::ConvolutionEngine;
use crate::dsp::parametric_eq::{BandConfig, FilterType, StereoParametricEQ};
use crate::sofa::loader::MySofa;
use crate::ui::speaker_visualizer::SpeakerVisualizer;
use cpal::traits::{DeviceTrait, HostTrait};
use egui_file_dialog::FileDialog;

#[derive(Debug, PartialEq, Eq, Clone, Copy, Enum, EnumIter, Serialize, Deserialize, Display)]
pub enum StereoAnglePreset {
    Manual,
    #[strum(to_string = "Equilateral (60°)")]
    Equilateral, // 60 degrees
    #[strum(to_string = "Near-field (70°)")]
    Nearfield, // 70 degrees
    #[strum(to_string = "Far-field (45°)")]
    Farfield, // 45 degrees
}

const NUM_EQ_BANDS: usize = 10;

// The headphone_index.json file generated by the build script.
const HEADPHONE_INDEX_JSON: &str = include_str!(concat!(env!("OUT_DIR"), "/headphone_index.json"));

#[derive(Serialize, Deserialize, Debug, Clone)]
struct Headphone {
    name: String,
    source: String,
    path: PathBuf,
}

pub enum Task {
    LoadSofa(PathBuf),
    LoadAutoEq(PathBuf, Arc<Mutex<Option<AutoEqProfile>>>),
    UpdateHeadphoneDatabase,
}

#[derive(Clone)]
pub enum ParamChange {
    ApplyEqProfile(AutoEqProfile),
}

#[derive(Params)]
pub struct EqBandParams {
    #[id = "en"]
    pub enabled: BoolParam,
    #[id = "type"]
    pub filter_type: EnumParam<FilterType>,
    #[id = "fc"]
    pub frequency: FloatParam,
    #[id = "q"]
    pub q: FloatParam,
    #[id = "gain"]
    pub gain: FloatParam,
}

impl Default for EqBandParams {
    fn default() -> Self {
        Self {
            enabled: BoolParam::new("Enabled", false),
            filter_type: EnumParam::new("Type", FilterType::Peak),
            frequency: FloatParam::new(
                "Frequency",
                1000.0,
                FloatRange::Skewed {
                    min: 20.0,
                    max: 20000.0,
                    factor: FloatRange::skew_factor(-2.0),
                },
            )
            .with_unit(" Hz")
            .with_smoother(SmoothingStyle::Logarithmic(50.0)),
            q: FloatParam::new(
                "Q",
                0.7,
                FloatRange::Linear {
                    min: 0.1,
                    max: 10.0,
                },
            )
            .with_smoother(SmoothingStyle::Linear(50.0)),
            gain: FloatParam::new(
                "Gain",
                0.0,
                FloatRange::Linear {
                    min: -16.0,
                    max: 16.0,
                },
            )
            .with_unit(" dB")
            .with_smoother(SmoothingStyle::Linear(50.0)),
        }
    }
}

#[derive(Params)]
pub struct OpenHeadstageParams {
    #[persist = "editor-state"]
    editor_state: Arc<EguiState>,

    #[persist = "sofa-path"]
    pub sofa_file_path: Arc<RwLock<String>>,

    #[persist = "audio-host"]
    pub audio_host: Arc<RwLock<String>>,
    #[persist = "audio-device"]
    pub audio_device: Arc<RwLock<String>>,

    #[id = "bypass"]
    pub master_bypass: BoolParam,

    #[id = "out_gain"]
    pub output_gain: FloatParam,

    #[id = "preamp_gain"]
    pub preamp_gain: FloatParam,

    // TODO: Future placeholder for surround sound configuration selector
    // This will involve a more complex enum and logic to handle various speaker layouts
    // (5.1, 7.1, Atmos, etc.)
    #[id = "stereo_preset"]
    pub stereo_preset: EnumParam<StereoAnglePreset>,

    #[id = "az_l"]
    pub speaker_azimuth_left: FloatParam,
    #[id = "el_l"]
    pub speaker_elevation_left: FloatParam,

    #[id = "az_r"]
    pub speaker_azimuth_right: FloatParam,
    #[id = "el_r"]
    pub speaker_elevation_right: FloatParam,

    #[id = "eq_enable"]
    pub eq_enable: BoolParam,

    #[nested(array, group = "EQ Bands")]
    pub eq_bands: Vec<EqBandParams>,
}

impl OpenHeadstageParams {
    fn new(config: StandaloneConfig) -> Self {
        let mut eq_bands = Vec::new();
        for i in 0..NUM_EQ_BANDS {
            let band_config = config.eq_bands.get(i).cloned().unwrap_or_default();
            eq_bands.push(EqBandParams {
                enabled: BoolParam::new("Enabled", band_config.enabled),
                filter_type: EnumParam::new("Type", band_config.filter_type),
                frequency: FloatParam::new(
                    "Frequency",
                    band_config.frequency,
                    FloatRange::Skewed {
                        min: 20.0,
                        max: 20000.0,
                        factor: FloatRange::skew_factor(-2.0),
                    },
                )
                .with_unit(" Hz")
                .with_smoother(SmoothingStyle::Logarithmic(50.0)),
                q: FloatParam::new(
                    "Q",
                    band_config.q,
                    FloatRange::Linear {
                        min: 0.1,
                        max: 10.0,
                    },
                )
                .with_smoother(SmoothingStyle::Linear(50.0)),
                gain: FloatParam::new(
                    "Gain",
                    band_config.gain,
                    FloatRange::Linear {
                        min: -16.0,
                        max: 16.0,
                    },
                )
                .with_unit(" dB")
                .with_smoother(SmoothingStyle::Linear(50.0)),
            });
        }

        Self {
            editor_state: EguiState::from_size(1794, 1047),
            sofa_file_path: Arc::new(RwLock::new(config.sofa_file_path)),
            audio_host: Arc::new(RwLock::new(config.audio_host)),
            audio_device: Arc::new(RwLock::new(config.audio_device)),
            master_bypass: BoolParam::new("Bypass", config.master_bypass),
            output_gain: FloatParam::new(
                "Output Gain",
                config.output_gain,
                FloatRange::Linear {
                    min: util::db_to_gain(-30.0),
                    max: util::db_to_gain(0.0),
                },
            )
            .with_smoother(SmoothingStyle::Logarithmic(50.0))
            .with_unit(" dB")
            .with_value_to_string(formatters::v2s_f32_gain_to_db(2))
            .with_string_to_value(formatters::s2v_f32_gain_to_db()),
            preamp_gain: FloatParam::new(
                "Preamp Gain",
                0.0,
                FloatRange::Linear {
                    min: -20.0,
                    max: 20.0,
                },
            )
            .with_unit(" dB")
            .with_smoother(SmoothingStyle::Linear(50.0)),
            stereo_preset: EnumParam::new("Stereo Preset", config.stereo_preset),
            speaker_azimuth_left: FloatParam::new(
                "L Azimuth",
                config.speaker_azimuth_left,
                FloatRange::Linear {
                    min: -90.0,
                    max: 90.0,
                },
            )
            .with_smoother(SmoothingStyle::Linear(50.0))
            .with_unit("°"),
            speaker_elevation_left: FloatParam::new(
                "L Elevation",
                config.speaker_elevation_left,
                FloatRange::Linear {
                    min: -45.0,
                    max: 45.0,
                },
            )
            .with_smoother(SmoothingStyle::Linear(50.0))
            .with_unit("°"),
            speaker_azimuth_right: FloatParam::new(
                "R Azimuth",
                config.speaker_azimuth_right,
                FloatRange::Linear {
                    min: -90.0,
                    max: 90.0,
                },
            )
            .with_smoother(SmoothingStyle::Linear(50.0))
            .with_unit("°"),
            speaker_elevation_right: FloatParam::new(
                "R Elevation",
                config.speaker_elevation_right,
                FloatRange::Linear {
                    min: -45.0,
                    max: 45.0,
                },
            )
            .with_smoother(SmoothingStyle::Linear(50.0))
            .with_unit("°"),
            eq_enable: BoolParam::new("Enable EQ", config.eq_enable),
            eq_bands,
        }
    }
}

#[derive(PartialEq, Eq, Clone, Copy)]
enum FileDialogRequest {
    Sofa,
}

struct Debouncer {
    last_update: Instant,
    delay: Duration,
}

impl Debouncer {
    fn new(delay: Duration) -> Self {
        Self {
            last_update: Instant::now(),
            delay,
        }
    }

    fn update(&mut self) {
        self.last_update = Instant::now();
    }

    fn ready(&self) -> bool {
        Instant::now().duration_since(self.last_update) > self.delay
    }
}

struct EditorState {
    file_dialog: FileDialog,
    file_dialog_request: Option<FileDialogRequest>,
    auto_eq_result_receiver: Arc<Mutex<Option<AutoEqProfile>>>,
    loaded_eq_profile: Option<AutoEqProfile>,
    show_eq_editor: bool,
    eq_editor_bands: Vec<BandSetting>,

    search_query: String,
    search_results: Vec<Headphone>,
    debouncer: Debouncer,

    // State for audio device selection
    available_hosts: Vec<cpal::HostId>,
    available_devices: Vec<String>,
    selected_host_id: cpal::HostId,
}

impl EditorState {
    fn new(
        auto_eq_result_receiver: Arc<Mutex<Option<AutoEqProfile>>>,
        initial_eq_params: &[EqBandParams],
        params: &OpenHeadstageParams,
    ) -> Self {
        let eq_editor_bands = initial_eq_params
            .iter()
            .map(|p| BandSetting {
                enabled: p.enabled.value(),
                filter_type: p.filter_type.value(),
                frequency: p.frequency.value(),
                q: p.q.value(),
                gain: p.gain.value(),
            })
            .collect();

        let available_hosts = cpal::available_hosts();
        let selected_host_id = available_hosts
            .iter()
            .find(|id| id.name() == *params.audio_host.read())
            .cloned()
            .unwrap_or_else(|| cpal::default_host().id());

        let available_devices = Self::get_output_devices_for_host(&selected_host_id);

        Self {
            file_dialog: FileDialog::new(),
            file_dialog_request: None,
            auto_eq_result_receiver,
            loaded_eq_profile: None,
            show_eq_editor: false,
            eq_editor_bands,

            search_query: String::new(),
            search_results: Vec::new(),
            debouncer: Debouncer::new(Duration::from_millis(200)),

            available_hosts,
            available_devices,
            selected_host_id,
        }
    }

    fn get_output_devices_for_host(host_id: &cpal::HostId) -> Vec<String> {
        cpal::host_from_id(*host_id)
            .ok()
            .and_then(|host| host.output_devices().ok())
            .map(|devices| {
                devices
                    .filter_map(|d| d.name().ok())
                    .collect::<Vec<String>>()
            })
            .unwrap_or_default()
    }
}

pub struct OpenHeadstagePlugin {
    params: Arc<OpenHeadstageParams>,
    convolution_engine: ConvolutionEngine,
    sofa_loader: Arc<parking_lot::Mutex<Option<MySofa>>>,
    parametric_eq: StereoParametricEQ,
    current_sample_rate: f32,

    headphone_index: Arc<RwLock<Vec<Headphone>>>,
    database_updated: Arc<AtomicBool>,

    param_change_sender: Sender<ParamChange>,
    param_change_receiver: Receiver<ParamChange>,

    auto_eq_result_receiver: Arc<Mutex<Option<AutoEqProfile>>>,
}

impl OpenHeadstagePlugin {
    pub fn new(sample_rate: f32, params: Arc<OpenHeadstageParams>) -> Self {
        let (tx, rx) = crossbeam_channel::unbounded();

        let headphone_index = serde_json::from_str(HEADPHONE_INDEX_JSON).unwrap_or_else(|e| {
            nih_log!("Failed to parse embedded headphone index: {}", e);
            Vec::new()
        });

        Self {
            params,
            convolution_engine: ConvolutionEngine::new(),
            sofa_loader: Arc::new(parking_lot::Mutex::new(None)),
            parametric_eq: StereoParametricEQ::new(NUM_EQ_BANDS, sample_rate),
            current_sample_rate: sample_rate,

            headphone_index: Arc::new(RwLock::new(headphone_index)),
            database_updated: Arc::new(AtomicBool::new(false)),

            param_change_sender: tx,
            param_change_receiver: rx,
            auto_eq_result_receiver: Arc::new(Mutex::new(None)),
        }
    }
}

#[derive(Serialize, Deserialize, Clone)]
struct StandaloneConfig {
    sofa_file_path: String,
    audio_host: String,
    audio_device: String,
    master_bypass: bool,
    output_gain: f32,
    preamp_gain: f32,
    stereo_preset: StereoAnglePreset,
    speaker_azimuth_left: f32,
    speaker_elevation_left: f32,
    speaker_azimuth_right: f32,
    speaker_elevation_right: f32,
    eq_enable: bool,
    eq_bands: Vec<BandSetting>,
}

impl Default for StandaloneConfig {
    fn default() -> Self {
        let default_params = OpenHeadstageParams::new(Self::pre_default());
        let mut eq_bands = Vec::new();
        for band in default_params.eq_bands.iter() {
            eq_bands.push(BandSetting {
                enabled: band.enabled.value(),
                filter_type: band.filter_type.value(),
                frequency: band.frequency.value(),
                q: band.q.value(),
                gain: band.gain.value(),
            });
        }

        Self {
            sofa_file_path: default_params.sofa_file_path.read().clone(),
            audio_host: default_params.audio_host.read().clone(),
            audio_device: default_params.audio_device.read().clone(),
            master_bypass: default_params.master_bypass.value(),
            output_gain: default_params.output_gain.value(),
            preamp_gain: default_params.preamp_gain.value(),
            stereo_preset: default_params.stereo_preset.value(),
            speaker_azimuth_left: default_params.speaker_azimuth_left.value(),
            speaker_elevation_left: default_params.speaker_elevation_left.value(),
            speaker_azimuth_right: default_params.speaker_azimuth_right.value(),
            speaker_elevation_right: default_params.speaker_elevation_right.value(),
            eq_enable: default_params.eq_enable.value(),
            eq_bands,
        }
    }
}

impl StandaloneConfig {
    // A special default for initializing the default params struct without infinite recursion
    fn pre_default() -> Self {
        Self {
            sofa_file_path: String::new(),
            audio_host: cpal::default_host().id().name().to_string(),
            audio_device: cpal::default_host()
                .default_output_device()
                .map(|d| d.name().unwrap_or_default())
                .unwrap_or_default(),
            master_bypass: false,
            output_gain: util::db_to_gain(0.0),
            preamp_gain: 0.0,
            stereo_preset: StereoAnglePreset::Equilateral,
            speaker_azimuth_left: -30.0,
            speaker_elevation_left: 0.0,
            speaker_azimuth_right: 30.0,
            speaker_elevation_right: 0.0,
            eq_enable: false,
            eq_bands: (0..NUM_EQ_BANDS).map(|_| BandSetting::default()).collect(),
        }
    }
}

fn save_standalone_config(params: &Arc<OpenHeadstageParams>) {
    let mut bands = Vec::new();
    for band in &params.eq_bands {
        bands.push(BandSetting {
            enabled: band.enabled.value(),
            filter_type: band.filter_type.value(),
            frequency: band.frequency.value(),
            q: band.q.value(),
            gain: band.gain.value(),
        });
    }

    let config = StandaloneConfig {
        sofa_file_path: params.sofa_file_path.read().clone(),
        audio_host: params.audio_host.read().clone(),
        audio_device: params.audio_device.read().clone(),
        master_bypass: params.master_bypass.value(),
        output_gain: params.output_gain.value(),
        preamp_gain: params.preamp_gain.value(),
        stereo_preset: params.stereo_preset.value(),
        speaker_azimuth_left: params.speaker_azimuth_left.value(),
        speaker_elevation_left: params.speaker_elevation_left.value(),
        speaker_azimuth_right: params.speaker_azimuth_right.value(),
        speaker_elevation_right: params.speaker_elevation_right.value(),
        eq_enable: params.eq_enable.value(),
        eq_bands: bands,
    };

    if let Some(config_path) = get_config_path() {
        if let Ok(json_str) = serde_json::to_string_pretty(&config) {
            let _ = fs::write(config_path, json_str);
        }
    }
}

impl Default for OpenHeadstagePlugin {
    fn default() -> Self {
        let config = get_config_path()
            .and_then(|p| fs::read_to_string(p).ok())
            .and_then(|s| serde_json::from_str(&s).ok())
            .unwrap_or_default();

        let params = Arc::new(OpenHeadstageParams::new(config));

        Self::new(44100.0, params)
    }
}

fn get_config_path() -> Option<PathBuf> {
    let mut config_path = dirs::config_dir()?;
    config_path.push(OpenHeadstagePlugin::VENDOR);
    config_path.push(OpenHeadstagePlugin::NAME);
    fs::create_dir_all(&config_path).ok()?;
    config_path.push("open_headstage_standalone.json");
    Some(config_path)
}

fn get_data_dir() -> Option<PathBuf> {
    let mut data_dir = env::current_exe().ok()?;
    data_dir.pop(); // remove executable name
    data_dir.pop(); // remove 'debug' or 'release'
    data_dir.pop(); // remove 'target'
    Some(data_dir)
}

impl Plugin for OpenHeadstagePlugin {
    const NAME: &'static str = "Open Headstage";
    const VENDOR: &'static str = "Open Source Community";
    const URL: &'static str = "http://example.com";
    const EMAIL: &'static str = "info@example.com";
    const VERSION: &'static str = env!("CARGO_PKG_VERSION");

    const AUDIO_IO_LAYOUTS: &'static [AudioIOLayout] = &[AudioIOLayout {
        main_input_channels: NonZeroU32::new(2),
        main_output_channels: NonZeroU32::new(2),
        ..AudioIOLayout::const_default()
    }];

    const MIDI_INPUT: MidiConfig = MidiConfig::None;
    const SAMPLE_ACCURATE_AUTOMATION: bool = true;

    type SysExMessage = ();
    type BackgroundTask = Task;

    fn params(&self) -> Arc<dyn Params> {
        self.params.clone()
    }

    fn editor(&mut self, async_executor: AsyncExecutor<Self>) -> Option<Box<dyn Editor>> {
        let params = self.params.clone();
        let headphone_index = self.headphone_index.clone();
        let database_updated = self.database_updated.clone();
        let auto_eq_result_receiver = self.auto_eq_result_receiver.clone();
        let param_change_sender = self.param_change_sender.clone();

        let editor_state =
            EditorState::new(auto_eq_result_receiver, &self.params.eq_bands, &self.params);

        create_egui_editor(
            self.params.editor_state.clone(),
            (
                editor_state,
                headphone_index,
                database_updated,
                param_change_sender,
            ),
            |_, _| {},
            move |egui_ctx,
                  setter,
                  (state, headphone_index, database_updated, param_change_sender)| {
                egui::CentralPanel::default().show(egui_ctx, |ui| {
                    egui::Frame::window(ui.style())
                        .inner_margin(egui::Margin::same(10))
                        .show(ui, |ui| {
                            egui::TopBottomPanel::top("title_bar")
                                .show_inside(ui, |ui| {
                                    ui.vertical_centered(|ui| {
                                        ui.heading(egui::RichText::new(Self::NAME).size(22.0));
                                    });
                                });

                            egui::CentralPanel::default().show_inside(ui, |ui| {
                                // Main controls panel
                                ui.add_space(10.0);

                                egui::collapsing_header::CollapsingHeader::new(
                                    egui::RichText::new("Master Output").size(22.0),
                                )
                                .default_open(true)
                                .show(ui, |ui| {
                                    ui.label("Output Gain");
                                    ui.add(widgets::ParamSlider::for_param(&params.output_gain, setter));
                                    ui.label("Preamp Gain");
                                    ui.add(widgets::ParamSlider::for_param(&params.preamp_gain, setter));
                                });

                                egui::collapsing_header::CollapsingHeader::new(
                                    egui::RichText::new("System Settings").size(22.0),
                                )
                                .default_open(true)
                                .show(ui, |ui| {
                                    ui.horizontal(|ui| {
                                        if ui.button("Save Settings").clicked() {
                                            save_standalone_config(&params);
                                        }
                                        if ui.button("Reset to Default").clicked() {
                                            let default_config = StandaloneConfig::default();
                                            let default_params = OpenHeadstageParams::new(default_config);

                                            // Programmatically reset all parameters
                                            setter.begin_set_parameter(&params.master_bypass);
                                            setter.set_parameter(&params.master_bypass, default_params.master_bypass.default_plain_value());
                                            setter.end_set_parameter(&params.master_bypass);

                                            setter.begin_set_parameter(&params.output_gain);
                                            setter.set_parameter(&params.output_gain, default_params.output_gain.default_plain_value());
                                            setter.end_set_parameter(&params.output_gain);
                                            setter.begin_set_parameter(&params.preamp_gain);
                                            setter.set_parameter(&params.preamp_gain, default_params.preamp_gain.default_plain_value());
                                            setter.end_set_parameter(&params.preamp_gain);

                                            setter.begin_set_parameter(&params.stereo_preset);
                                            setter.set_parameter(&params.stereo_preset, default_params.stereo_preset.default_plain_value());
                                            setter.end_set_parameter(&params.stereo_preset);

                                            setter.begin_set_parameter(&params.speaker_azimuth_left);
                                            setter.set_parameter(&params.speaker_azimuth_left, default_params.speaker_azimuth_left.default_plain_value());
                                            setter.end_set_parameter(&params.speaker_azimuth_left);

                                            setter.begin_set_parameter(&params.speaker_elevation_left);
                                            setter.set_parameter(&params.speaker_elevation_left, default_params.speaker_elevation_left.default_plain_value());
                                            setter.end_set_parameter(&params.speaker_elevation_left);

                                            setter.begin_set_parameter(&params.speaker_azimuth_right);
                                            setter.set_parameter(&params.speaker_azimuth_right, default_params.speaker_azimuth_right.default_plain_value());
                                            setter.end_set_parameter(&params.speaker_azimuth_right);

                                            setter.begin_set_parameter(&params.speaker_elevation_right);
                                            setter.set_parameter(&params.speaker_elevation_right, default_params.speaker_elevation_right.default_plain_value());
                                            setter.end_set_parameter(&params.speaker_elevation_right);

                                            setter.begin_set_parameter(&params.eq_enable);
                                            setter.set_parameter(&params.eq_enable, default_params.eq_enable.default_plain_value());
                                            setter.end_set_parameter(&params.eq_enable);

                                            for (i, band_params) in params.eq_bands.iter().enumerate() {
                                                let default_band = &default_params.eq_bands[i];
                                                setter.begin_set_parameter(&band_params.enabled);
                                                setter.set_parameter(&band_params.enabled, default_band.enabled.default_plain_value());
                                                setter.end_set_parameter(&band_params.enabled);

                                                setter.begin_set_parameter(&band_params.filter_type);
                                                setter.set_parameter(&band_params.filter_type, default_band.filter_type.default_plain_value());
                                                setter.end_set_parameter(&band_params.filter_type);

                                                setter.begin_set_parameter(&band_params.frequency);
                                                setter.set_parameter(&band_params.frequency, default_band.frequency.default_plain_value());
                                                setter.end_set_parameter(&band_params.frequency);

                                                setter.begin_set_parameter(&band_params.q);
                                                setter.set_parameter(&band_params.q, default_band.q.default_plain_value());
                                                setter.end_set_parameter(&band_params.q);

                                                setter.begin_set_parameter(&band_params.gain);
                                                setter.set_parameter(&band_params.gain, default_band.gain.default_plain_value());
                                                setter.end_set_parameter(&band_params.gain);
                                            }
                                        }
                                    });

                                    ui.separator();

                                    let selected_host_name = state.selected_host_id.name();
                                    egui::ComboBox::from_label("Host")
                                        .selected_text(selected_host_name)
                                        .show_ui(ui, |ui| {
                                            for host_id in &state.available_hosts {
                                                if ui.selectable_value(&mut state.selected_host_id, host_id.clone(), host_id.name()).changed() {
                                                    state.available_devices = EditorState::get_output_devices_for_host(&state.selected_host_id);
                                                    *params.audio_host.write() = state.selected_host_id.name().to_string();
                                                    // Select the default device for the new host
                                                    if let Some(default_device) = cpal::host_from_id(state.selected_host_id.clone()).ok().and_then(|h| h.default_output_device()).and_then(|d| d.name().ok()) {
                                                        *params.audio_device.write() = default_device;
                                                    } else if let Some(first_device) = state.available_devices.first() {
                                                        *params.audio_device.write() = first_device.clone();
                                                    } else {
                                                        *params.audio_device.write() = String::new();
                                                    }
                                                }
                                            }
                                        });

                                    let mut selected_device_name = params.audio_device.read().clone();
                                    egui::ComboBox::from_label("Device")
                                        .selected_text(&selected_device_name)
                                        .show_ui(ui, |ui| {
                                            for device_name in &state.available_devices {
                                                if ui.selectable_value(&mut selected_device_name, device_name.clone(), device_name).changed() {
                                                    *params.audio_device.write() = selected_device_name.clone();
                                                }
                                            }
                                        });
                                });

                                egui::collapsing_header::CollapsingHeader::new(
                                    egui::RichText::new("Speaker Configuration").size(22.0),
                                )
                                .default_open(true)
                                .show(ui, |ui| {
                                    ui.add(SpeakerVisualizer {
                                        left_azimuth: params.speaker_azimuth_left.value(),
                                        left_elevation: params.speaker_elevation_left.value(),
                                        right_azimuth: params.speaker_azimuth_right.value(),
                                        right_elevation: params.speaker_elevation_right.value(),
                                    });

                                    // Get the current preset value
                                    let mut selected_preset = params.stereo_preset.value();
                                    let mut changed = false;

                                    // Create the ComboBox and check if its value changed
                                    ui.horizontal(|ui| {
                                        ui.label("Preset");
                                        egui::ComboBox::from_id_source("stereo_preset_selector")
                                            .selected_text(selected_preset.to_string())
                                            .show_ui(ui, |ui| {
                                                for preset in StereoAnglePreset::iter() {
                                                    if ui.selectable_value(&mut selected_preset, preset, preset.to_string()).changed() {
                                                        changed = true;
                                                    }
                                                }
                                            });
                                    });

                                    // If the user selected a new preset, apply the logic
                                    if changed {
                                        setter.begin_set_parameter(&params.stereo_preset);
                                        setter.set_parameter(&params.stereo_preset, selected_preset);
                                        setter.end_set_parameter(&params.stereo_preset);

                                        let (az_l, az_r) = match selected_preset {
                                            StereoAnglePreset::Equilateral => (-30.0, 30.0),
                                            StereoAnglePreset::Nearfield => (-35.0, 35.0),
                                            StereoAnglePreset::Farfield => (-22.5, 22.5),
                                            StereoAnglePreset::Manual => (params.speaker_azimuth_left.value(), params.speaker_azimuth_right.value()),
                                        };

                                        if selected_preset != StereoAnglePreset::Manual {
                                            setter.begin_set_parameter(&params.speaker_azimuth_left);
                                            setter.set_parameter(&params.speaker_azimuth_left, az_l);
                                            setter.end_set_parameter(&params.speaker_azimuth_left);

                                            setter.begin_set_parameter(&params.speaker_azimuth_right);
                                            setter.set_parameter(&params.speaker_azimuth_right, az_r);
                                            setter.end_set_parameter(&params.speaker_azimuth_right);
                                        }
                                    }

                                    // Determine if the sliders should be enabled
                                    let is_manual = selected_preset == StereoAnglePreset::Manual;

                                    // The Grid for the sliders
                                    egui::Grid::new("speaker_grid")
                                        .num_columns(3)
                                        .spacing([40.0, 4.0])
                                        .show(ui, |ui| {
                                            ui.label(""); // Dummy label for alignment
                                            ui.label("Left");
                                            ui.label("Right");
                                            ui.end_row();

                                            ui.label("Azimuth");
                                            // Use ui.add_enabled to conditionally disable the sliders
                                            if ui.add_enabled(is_manual, widgets::ParamSlider::for_param(&params.speaker_azimuth_left, setter)).changed() {
                                                setter.begin_set_parameter(&params.speaker_azimuth_left);
                                                setter.set_parameter(&params.speaker_azimuth_left, params.speaker_azimuth_left.value());
                                                setter.end_set_parameter(&params.speaker_azimuth_left);
                                            }
                                            if ui.add_enabled(is_manual, widgets::ParamSlider::for_param(&params.speaker_azimuth_right, setter)).changed() {
                                                setter.begin_set_parameter(&params.speaker_azimuth_right);
                                                setter.set_parameter(&params.speaker_azimuth_right, params.speaker_azimuth_right.value());
                                                setter.end_set_parameter(&params.speaker_azimuth_right);
                                            }
                                            ui.end_row();

                                            ui.label("Elevation");
                                            // Elevation is always enabled in this design
                                            if ui.add(widgets::ParamSlider::for_param(
                                                &params.speaker_elevation_left,
                                                setter,
                                            )).changed() {
                                                setter.begin_set_parameter(&params.speaker_elevation_left);
                                                setter.set_parameter(&params.speaker_elevation_left, params.speaker_elevation_left.value());
                                                setter.end_set_parameter(&params.speaker_elevation_left);
                                            }
                                            if ui.add(widgets::ParamSlider::for_param(
                                                &params.speaker_elevation_right,
                                                setter,
                                            )).changed() {
                                                setter.begin_set_parameter(&params.speaker_elevation_right);
                                                setter.set_parameter(&params.speaker_elevation_right, params.speaker_elevation_right.value());
                                                setter.end_set_parameter(&params.speaker_elevation_right);
                                            }
                                            ui.end_row();
                                        });
                                });

                                egui::collapsing_header::CollapsingHeader::new(
                                    egui::RichText::new("Headphone Equalization").size(22.0),
                                )
                                .default_open(true)
                                .show(ui, |ui| {
                                    ui.horizontal(|ui| {
                                        if ui.button("Select SOFA File").clicked() {
                                            state.file_dialog.pick_file();
                                            state.file_dialog_request = Some(FileDialogRequest::Sofa);
                                        }
                                        if ui.button("Edit Parametric EQ").clicked() {
                                            state.show_eq_editor = !state.show_eq_editor;
                                            if state.show_eq_editor {
                                                // Sync the editor state with the current params
                                                state.eq_editor_bands = params.eq_bands.iter().map(|p| BandSetting {
                                                    enabled: p.enabled.value(),
                                                    filter_type: p.filter_type.value(),
                                                    frequency: p.frequency.value(),
                                                    q: p.q.value(),
                                                    gain: p.gain.value(),
                                                }).collect();
                                            }
                                        }
                                    });

                                    if let Some(path) = state.file_dialog.update(egui_ctx).picked() {
                                        match state.file_dialog_request {
                                            Some(FileDialogRequest::Sofa) => {
                                                let path_buf = path.to_path_buf();
                                                *params.sofa_file_path.write() = path_buf.to_string_lossy().to_string();
                                                async_executor.execute_background(Task::LoadSofa(path_buf));
                                            }
                                            None => (),
                                        }
                                        state.file_dialog_request = None;
                                    }

                                    ui.separator();

                                    ui.horizontal(|ui| {
                                        ui.label("AutoEQ Profile Search:");
                                        if ui.button("Update Database").clicked() {
                                            async_executor.execute_background(Task::UpdateHeadphoneDatabase);
                                        }
                                    });

                                    if database_updated.swap(false, Ordering::Relaxed) {
                                        nih_log!("UI: Database updated, please restart the plugin to see changes.");
                                    }

                                    let query_changed = ui.text_edit_singleline(&mut state.search_query).changed();
                                    if query_changed {
                                        state.debouncer.update();
                                    }

                                    if state.debouncer.ready() && !state.search_query.is_empty() {
                                        let query = state.search_query.to_lowercase();
                                        let mut results = headphone_index
                                            .read()
                                            .iter()
                                            .filter(|h| h.name.to_lowercase().contains(&query))
                                            .cloned()
                                            .collect::<Vec<_>>();

                                        // Prioritize oratory1990 results and sort alphabetically
                                        results.sort_by(|a, b| {
                                            let a_is_oratory = a.source == "oratory1990";
                                            let b_is_oratory = b.source == "oratory1990";
                                            b_is_oratory.cmp(&a_is_oratory).then_with(|| a.name.cmp(&b.name))
                                        });

                                        state.search_results = results.into_iter().take(100).collect();
                                    } else if state.search_query.is_empty() {
                                        state.search_results.clear();
                                    }
                                    egui::ScrollArea::vertical().show(ui, |ui| {
                                        for headphone in &state.search_results {
                                            let display_text = format!("{} ({})", headphone.name, headphone.source);
                                            if ui.button(display_text).clicked() {
                                                let result_mutex = state.auto_eq_result_receiver.clone();
                                                async_executor.execute_background(Task::LoadAutoEq(
                                                    headphone.path.clone(),
                                                    result_mutex,
                                                ));
                                            }
                                        }
                                    });

                                    if let Some(profile) = state.auto_eq_result_receiver.lock().take() {
                                        state.loaded_eq_profile = Some(profile);
                                    }

                                    if let Some(profile) = &state.loaded_eq_profile {
                                         if ui.button("Apply Loaded EQ").clicked() {
                                            setter.begin_set_parameter(&params.preamp_gain);
                                            setter.set_parameter(&params.preamp_gain, profile.preamp);
                                            setter.end_set_parameter(&params.preamp_gain);

                                            setter.begin_set_parameter(&params.eq_enable);
                                            setter.set_parameter(&params.eq_enable, true);
                                            setter.end_set_parameter(&params.eq_enable);

                                            for (i, band_setting) in profile.bands.iter().enumerate() {
                                                if let Some(band_params) = params.eq_bands.get(i) {
                                                    setter.begin_set_parameter(&band_params.enabled);
                                                    setter.set_parameter(&band_params.enabled, band_setting.enabled);
                                                    setter.end_set_parameter(&band_params.enabled);

                                                    setter.begin_set_parameter(&band_params.filter_type);
                                                    setter.set_parameter(&band_params.filter_type, band_setting.filter_type);
                                                    setter.end_set_parameter(&band_params.filter_type);

                                                    setter.begin_set_parameter(&band_params.frequency);
                                                    setter.set_parameter(&band_params.frequency, band_setting.frequency);
                                                    setter.end_set_parameter(&band_params.frequency);

                                                    setter.begin_set_parameter(&band_params.q);
                                                    setter.set_parameter(&band_params.q, band_setting.q);
                                                    setter.end_set_parameter(&band_params.q);

                                                    setter.begin_set_parameter(&band_params.gain);
                                                    setter.set_parameter(&band_params.gain, band_setting.gain);
                                                    setter.end_set_parameter(&band_params.gain);
                                                }
                                            }
                                            // Also send the profile to the audio thread to update coefficients
                                            param_change_sender.send(ParamChange::ApplyEqProfile(profile.clone())).unwrap();
                                         }
                                    }
                                });
                            });
                        });

                    if state.show_eq_editor {
                        egui::SidePanel::right("peq_editor")
                            .resizable(true)
                            .default_width(500.0)
                            .show(egui_ctx, |ui| {
                                egui::ScrollArea::vertical().show(ui, |ui| {
                                    ui.heading("Parametric EQ");

                                    ui.horizontal(|ui| {
                                        if ui.button("Apply").clicked() {
                                            setter.begin_set_parameter(&params.eq_enable);
                                            setter.set_parameter(&params.eq_enable, true);
                                            setter.end_set_parameter(&params.eq_enable);

                                            let new_profile = AutoEqProfile {
                                                preamp: params.preamp_gain.value(),
                                                bands: state.eq_editor_bands.clone(),
                                            };

                                            for (i, band_setting) in state.eq_editor_bands.iter().enumerate() {
                                                if let Some(band_params) = params.eq_bands.get(i) {
                                                    setter.begin_set_parameter(&band_params.enabled);
                                                    setter.set_parameter(&band_params.enabled, band_setting.enabled);
                                                    setter.end_set_parameter(&band_params.enabled);

                                                    setter.begin_set_parameter(&band_params.filter_type);
                                                    setter.set_parameter(&band_params.filter_type, band_setting.filter_type);
                                                    setter.end_set_parameter(&band_params.filter_type);

                                                    setter.begin_set_parameter(&band_params.frequency);
                                                    setter.set_parameter(&band_params.frequency, band_setting.frequency);
                                                    setter.end_set_parameter(&band_params.frequency);

                                                    setter.begin_set_parameter(&band_params.q);
                                                    setter.set_parameter(&band_params.q, band_setting.q);
                                                    setter.end_set_parameter(&band_params.q);

                                                    setter.begin_set_parameter(&band_params.gain);
                                                    setter.set_parameter(&band_params.gain, band_setting.gain);
                                                    setter.end_set_parameter(&band_params.gain);
                                                }
                                            }
                                            param_change_sender.send(ParamChange::ApplyEqProfile(new_profile)).unwrap();
                                            state.show_eq_editor = false;
                                        }
                                        if ui.button("Cancel").clicked() {
                                            state.show_eq_editor = false;
                                        }
                                    });

                                    ui.separator();

                                    egui::Grid::new("peq_grid").num_columns(5).show(ui, |ui| {
                                        ui.label("On");
                                        ui.label("Type");
                                        ui.label("Freq");
                                        ui.label("Q");
                                        ui.label("Gain");
                                        ui.end_row();

                                        for band in &mut state.eq_editor_bands {
                                            ui.checkbox(&mut band.enabled, "");
                                            egui::ComboBox::new(format!("filter_type_{}", band.frequency), "")
                                                .selected_text(format!("{:?}", band.filter_type))
                                                .show_ui(ui, |ui| {
                                                    for filter_type in FilterType::iter() {
                                                        ui.selectable_value(&mut band.filter_type, filter_type, format!("{:?}", filter_type));
                                                    }
                                                });

                                            ui.add(
                                                egui::DragValue::new(&mut band.frequency)
                                                    .speed(1.0)
                                                    .range(20.0..=20000.0)
                                                    .suffix(" Hz"),
                                            );
                                            ui.add(
                                                egui::DragValue::new(&mut band.q)
                                                    .speed(0.01)
                                                    .range(0.1..=10.0),
                                            );
                                            ui.add(
                                                egui::DragValue::new(&mut band.gain)
                                                    .speed(0.1)
                                                    .range(-16.0..=16.0)
                                                    .suffix(" dB"),
                                            );
                                            ui.end_row();
                                        }
                                    });
                                });
                            });
                    }
                });
            },
        )
    }

    fn task_executor(&mut self) -> Box<dyn Fn(Self::BackgroundTask) + Send> {
        let sample_rate = self.current_sample_rate;
        let sofa_loader = self.sofa_loader.clone();
        let database_updated = self.database_updated.clone();

        Box::new(move |task| {
            let data_dir = match get_data_dir() {
                Some(dir) => dir,
                None => {
                    nih_log!("BACKGROUND: Could not determine data directory. Tasks will fail.");
                    return;
                }
            };

            match task {
                Task::LoadSofa(path) => {
                    nih_log!("BACKGROUND: Loading SOFA file from: {:?}", path);
                    match MySofa::open(path.to_string_lossy().as_ref(), sample_rate) {
                        Ok(loader) => {
                            nih_log!("BACKGROUND: Successfully loaded SOFA file: {:?}", path);
                            *sofa_loader.lock() = Some(loader);
                        }
                        Err(e) => {
                            nih_log!("BACKGROUND: Failed to load SOFA file '{:?}': {:?}", path, e);
                            *sofa_loader.lock() = None;
                        }
                    }
                }
                Task::LoadAutoEq(path, result_mutex) => {
                    let absolute_path = data_dir.join(&path);
                    nih_log!(
                        "BACKGROUND: Loading AutoEQ profile from: {:?}",
                        absolute_path
                    );
                    match parse_autoeq_file(&absolute_path) {
                        Ok(profile) => {
                            nih_log!(
                                "BACKGROUND: Successfully parsed AutoEQ profile from {:?}.",
                                absolute_path
                            );
                            *result_mutex.lock() = Some(profile);
                        }
                        Err(e) => {
                            nih_log!(
                                "BACKGROUND: Failed to parse AutoEQ file '{:?}': {:?}",
                                absolute_path,
                                e
                            );
                        }
                    }
                }
                Task::UpdateHeadphoneDatabase => {
                    let autoeq_dir = data_dir.join("PRESERVE/AutoEq");
                    nih_log!(
                        "BACKGROUND: Updating headphone database in {:?}...",
                        autoeq_dir
                    );
                    let git_pull_status = Command::new("git")
                        .arg("pull")
                        .current_dir(&autoeq_dir)
                        .status();

                    match git_pull_status {
                        Ok(status) if status.success() => {
                            nih_log!("BACKGROUND: Git pull successful. Re-indexing...");
                            database_updated.store(true, Ordering::Relaxed);
                        }
                        Ok(status) => {
                            nih_log!("BACKGROUND: Git pull failed with status: {}", status);
                        }
                        Err(e) => {
                            nih_log!(
                                "BACKGROUND: Failed to execute git pull in {:?}: {}",
                                autoeq_dir,
                                e
                            );
                        }
                    }
                }
            }
        })
    }

    fn initialize(
        &mut self,
        _audio_io_layout: &AudioIOLayout,
        buffer_config: &BufferConfig,
        _context: &mut impl InitContext<Self>,
    ) -> bool {
        self.current_sample_rate = buffer_config.sample_rate;
        true
    }

    fn reset(&mut self) {
        self.parametric_eq.reset_all_bands_state();
    }

    fn process(
        &mut self,
        buffer: &mut Buffer,
        _aux: &mut AuxiliaryBuffers,
        _context: &mut impl ProcessContext<Self>,
    ) -> ProcessStatus {
        while let Ok(change) = self.param_change_receiver.try_recv() {
            match change {
                ParamChange::ApplyEqProfile(profile) => {
                    for (i, band_setting) in profile.bands.iter().enumerate() {
                        let band_config = BandConfig {
                            filter_type: band_setting.filter_type,
                            center_freq: band_setting.frequency,
                            q: band_setting.q,
                            gain_db: band_setting.gain,
                            enabled: band_setting.enabled,
                        };
                        self.parametric_eq.update_band_coeffs(
                            i,
                            self.current_sample_rate,
                            &band_config,
                        );
                    }
                }
            }
        }

        if !self.params.master_bypass.value() {
            let _az_l = self.params.speaker_azimuth_left.smoothed.next();
            let _el_l = self.params.speaker_elevation_left.smoothed.next();
            let _az_r = self.params.speaker_azimuth_right.smoothed.next();
            let _el_r = self.params.speaker_elevation_right.smoothed.next();

            let [left, right] = buffer.as_slice() else {
                return ProcessStatus::Error("Mismatched channel count");
            };

            if self.params.eq_enable.value() {
                self.parametric_eq.process_block(left, right);
            }

            let mut input_l = vec![0.0; left.len()];
            input_l.copy_from_slice(left);
            let mut input_r = vec![0.0; right.len()];
            input_r.copy_from_slice(right);

            self.convolution_engine
                .process_block(&input_l, &input_r, left, right);

            let master_gain = self.params.output_gain.smoothed.next();
            let preamp_gain = util::db_to_gain(self.params.preamp_gain.smoothed.next());
            for mut channel_samples in buffer.iter_samples() {
                for sample in channel_samples.iter_mut() {
                    *sample *= master_gain * preamp_gain;
                }
            }
        }

        ProcessStatus::Normal
    }
}
