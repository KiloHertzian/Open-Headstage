// Copyright 2025 SignalVerse
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crossbeam_channel::{Receiver, Sender};
use nih_plug::prelude::*;
use nih_plug_egui::{create_egui_editor, egui, widgets, EguiState};
use parking_lot::{Mutex, RwLock};
use serde::{Deserialize, Serialize};
use serde_json;
use std::fs;
use std::path::PathBuf;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::time::{Duration, Instant};
use std::process::Command;

// Make sure our modules are declared
mod autoeq_parser;
mod dsp;
mod sofa;
mod ui;

use crate::autoeq_parser::{parse_autoeq_file, AutoEqProfile, BandSetting};
use crate::dsp::convolution::ConvolutionEngine;
use crate::dsp::parametric_eq::{BandConfig, FilterType, StereoParametricEQ};
use crate::sofa::loader::MySofa;
use crate::ui::speaker_visualizer::SpeakerVisualizer;
use cpal::traits::{DeviceTrait, HostTrait};
use egui_file_dialog::FileDialog;

const NUM_EQ_BANDS: usize = 10;

// The headphone_index.json file generated by the build script.
const HEADPHONE_INDEX_JSON: &str = include_str!(concat!(env!("OUT_DIR"), "/headphone_index.json"));

#[derive(Serialize, Deserialize, Debug, Clone)]
struct Headphone {
    name: String,
    source: String,
    path: PathBuf,
}

pub enum Task {
    LoadSofa(PathBuf),
    LoadAutoEq(PathBuf, Arc<Mutex<Option<AutoEqProfile>>>),
    UpdateHeadphoneDatabase,
}

#[derive(Clone)]
pub enum ParamChange {
    ApplyEqProfile(AutoEqProfile),
}

#[derive(Params)]
pub struct EqBandParams {
    #[id = "en"]
    pub enabled: BoolParam,
    #[id = "type"]
    pub filter_type: EnumParam<FilterType>,
    #[id = "fc"]
    pub frequency: FloatParam,
    #[id = "q"]
    pub q: FloatParam,
    #[id = "gain"]
    pub gain: FloatParam,
}

impl Default for EqBandParams {
    fn default() -> Self {
        Self {
            enabled: BoolParam::new("Enabled", false),
            filter_type: EnumParam::new("Type", FilterType::Peak),
            frequency: FloatParam::new(
                "Frequency",
                1000.0,
                FloatRange::Skewed {
                    min: 20.0,
                    max: 20000.0,
                    factor: FloatRange::skew_factor(-2.0),
                },
            )
            .with_unit(" Hz")
            .with_smoother(SmoothingStyle::Logarithmic(50.0)),
            q: FloatParam::new(
                "Q",
                0.7,
                FloatRange::Linear {
                    min: 0.1,
                    max: 10.0,
                },
            )
            .with_smoother(SmoothingStyle::Linear(50.0)),
            gain: FloatParam::new(
                "Gain",
                0.0,
                FloatRange::Linear {
                    min: -16.0,
                    max: 16.0,
                },
            )
            .with_unit(" dB")
            .with_smoother(SmoothingStyle::Linear(50.0)),
        }
    }
}

#[derive(Params)]
pub struct OpenHeadstageParams {
    #[persist = "editor-state"]
    editor_state: Arc<EguiState>,

    #[persist = "sofa-path"]
    pub sofa_file_path: Arc<RwLock<String>>,

    #[persist = "audio-host"]
    pub audio_host: Arc<RwLock<String>>,
    #[persist = "audio-device"]
    pub audio_device: Arc<RwLock<String>>,

    #[id = "bypass"]
    pub master_bypass: BoolParam,

    #[id = "out_gain"]
    pub output_gain: FloatParam,
    
    #[id = "preamp_gain"]
    pub preamp_gain: FloatParam,

    #[id = "az_l"]
    pub speaker_azimuth_left: FloatParam,
    #[id = "el_l"]
    pub speaker_elevation_left: FloatParam,

    #[id = "az_r"]
    pub speaker_azimuth_right: FloatParam,
    #[id = "el_r"]
    pub speaker_elevation_right: FloatParam,

    #[id = "eq_enable"]
    pub eq_enable: BoolParam,

    #[nested(array, group = "EQ Bands")]
    pub eq_bands: Vec<EqBandParams>,
}

impl OpenHeadstageParams {
    fn new(config: StandaloneConfig) -> Self {
        let mut eq_bands = Vec::new();
        for i in 0..NUM_EQ_BANDS {
            let band_config = config.eq_bands.get(i).cloned().unwrap_or_default();
            eq_bands.push(EqBandParams {
                enabled: BoolParam::new("Enabled", band_config.enabled),
                filter_type: EnumParam::new("Type", band_config.filter_type),
                frequency: FloatParam::new(
                    "Frequency",
                    band_config.frequency,
                    FloatRange::Skewed {
                        min: 20.0,
                        max: 20000.0,
                        factor: FloatRange::skew_factor(-2.0),
                    },
                )
                .with_unit(" Hz")
                .with_smoother(SmoothingStyle::Logarithmic(50.0)),
                q: FloatParam::new(
                    "Q",
                    band_config.q,
                    FloatRange::Linear {
                        min: 0.1,
                        max: 10.0,
                    },
                )
                .with_smoother(SmoothingStyle::Linear(50.0)),
                gain: FloatParam::new(
                    "Gain",
                    band_config.gain,
                    FloatRange::Linear {
                        min: -16.0,
                        max: 16.0,
                    },
                )
                .with_unit(" dB")
                .with_smoother(SmoothingStyle::Linear(50.0)),
            });
        }

        Self {
            editor_state: EguiState::from_size(1380, 805),
            sofa_file_path: Arc::new(RwLock::new(config.sofa_file_path)),
            audio_host: Arc::new(RwLock::new(config.audio_host)),
            audio_device: Arc::new(RwLock::new(config.audio_device)),
            master_bypass: BoolParam::new("Bypass", config.master_bypass),
            output_gain: FloatParam::new(
                "Output Gain",
                config.output_gain,
                FloatRange::Linear {
                    min: util::db_to_gain(-30.0),
                    max: util::db_to_gain(0.0),
                },
            )
            .with_smoother(SmoothingStyle::Logarithmic(50.0))
            .with_unit(" dB")
            .with_value_to_string(formatters::v2s_f32_gain_to_db(2))
            .with_string_to_value(formatters::s2v_f32_gain_to_db()),
            preamp_gain: FloatParam::new(
                "Preamp Gain",
                0.0,
                FloatRange::Linear { min: -20.0, max: 20.0 }
            ).with_unit(" dB").with_smoother(SmoothingStyle::Linear(50.0)),
            speaker_azimuth_left: FloatParam::new(
                "L Azimuth",
                config.speaker_azimuth_left,
                FloatRange::Linear {
                    min: -90.0,
                    max: 90.0,
                },
            )
            .with_smoother(SmoothingStyle::Linear(50.0))
            .with_unit("째"),
            speaker_elevation_left: FloatParam::new(
                "L Elevation",
                config.speaker_elevation_left,
                FloatRange::Linear {
                    min: -45.0,
                    max: 45.0,
                },
            )
            .with_smoother(SmoothingStyle::Linear(50.0))
            .with_unit("째"),
            speaker_azimuth_right: FloatParam::new(
                "R Azimuth",
                config.speaker_azimuth_right,
                FloatRange::Linear {
                    min: -90.0,
                    max: 90.0,
                },
            )
            .with_smoother(SmoothingStyle::Linear(50.0))
            .with_unit("째"),
            speaker_elevation_right: FloatParam::new(
                "R Elevation",
                config.speaker_elevation_right,
                FloatRange::Linear {
                    min: -45.0,
                    max: 45.0,
                },
            )
            .with_smoother(SmoothingStyle::Linear(50.0))
            .with_unit("째"),
            eq_enable: BoolParam::new("Enable EQ", config.eq_enable),
            eq_bands,
        }
    }
}

#[derive(PartialEq, Eq, Clone, Copy)]
enum FileDialogRequest {
    Sofa,
}

struct Debouncer {
    last_update: Instant,
    delay: Duration,
}

impl Debouncer {
    fn new(delay: Duration) -> Self {
        Self {
            last_update: Instant::now(),
            delay,
        }
    }

    fn update(&mut self) {
        self.last_update = Instant::now();
    }

    fn ready(&self) -> bool {
        Instant::now().duration_since(self.last_update) > self.delay
    }
}


struct EditorState {
    file_dialog: FileDialog,
    file_dialog_request: Option<FileDialogRequest>,
    auto_eq_result_receiver: Arc<Mutex<Option<AutoEqProfile>>>,
    loaded_eq_profile: Option<AutoEqProfile>,
    show_eq_editor: bool,
    
    search_query: String,
    search_results: Vec<Headphone>,
    debouncer: Debouncer,
}

impl EditorState {
    fn new(
        auto_eq_result_receiver: Arc<Mutex<Option<AutoEqProfile>>>,
    ) -> Self {
        Self {
            file_dialog: FileDialog::new(),
            file_dialog_request: None,
            auto_eq_result_receiver,
            loaded_eq_profile: None,
            show_eq_editor: false,
            
            search_query: String::new(),
            search_results: Vec::new(),
            debouncer: Debouncer::new(Duration::from_millis(200)),
        }
    }
}

pub struct OpenHeadstagePlugin {
    params: Arc<OpenHeadstageParams>,
    convolution_engine: ConvolutionEngine,
    sofa_loader: Arc<parking_lot::Mutex<Option<MySofa>>>,
    parametric_eq: StereoParametricEQ,
    current_sample_rate: f32,
    
    headphone_index: Arc<RwLock<Vec<Headphone>>>,
    database_updated: Arc<AtomicBool>,
    
    param_change_sender: Sender<ParamChange>,
    param_change_receiver: Receiver<ParamChange>,

    auto_eq_result_receiver: Arc<Mutex<Option<AutoEqProfile>>>,
}

impl OpenHeadstagePlugin {
    pub fn new(sample_rate: f32, params: Arc<OpenHeadstageParams>) -> Self {
        let (tx, rx) = crossbeam_channel::unbounded();
        
        let headphone_index = serde_json::from_str(HEADPHONE_INDEX_JSON).unwrap_or_else(|e| {
            nih_log!("Failed to parse embedded headphone index: {}", e);
            Vec::new()
        });

        Self {
            params,
            convolution_engine: ConvolutionEngine::new(),
            sofa_loader: Arc::new(parking_lot::Mutex::new(None)),
            parametric_eq: StereoParametricEQ::new(NUM_EQ_BANDS, sample_rate),
            current_sample_rate: sample_rate,
            
            headphone_index: Arc::new(RwLock::new(headphone_index)),
            database_updated: Arc::new(AtomicBool::new(false)),

            param_change_sender: tx,
            param_change_receiver: rx,
            auto_eq_result_receiver: Arc::new(Mutex::new(None)),
        }
    }
}

#[derive(Serialize, Deserialize, Clone)]
struct StandaloneConfig {
    sofa_file_path: String,
    audio_host: String,
    audio_device: String,
    master_bypass: bool,
    output_gain: f32,
    speaker_azimuth_left: f32,
    speaker_elevation_left: f32,
    speaker_azimuth_right: f32,
    speaker_elevation_right: f32,
    eq_enable: bool,
    eq_bands: Vec<BandSetting>,
}

impl Default for StandaloneConfig {
    fn default() -> Self {
        let default_params = OpenHeadstageParams::new(Self::pre_default());
        let mut eq_bands = Vec::new();
        for band in default_params.eq_bands.iter() {
            eq_bands.push(BandSetting {
                enabled: band.enabled.value(),
                filter_type: band.filter_type.value(),
                frequency: band.frequency.value(),
                q: band.q.value(),
                gain: band.gain.value(),
            });
        }

        Self {
            sofa_file_path: default_params.sofa_file_path.read().clone(),
            audio_host: default_params.audio_host.read().clone(),
            audio_device: default_params.audio_device.read().clone(),
            master_bypass: default_params.master_bypass.value(),
            output_gain: default_params.output_gain.value(),
            speaker_azimuth_left: default_params.speaker_azimuth_left.value(),
            speaker_elevation_left: default_params.speaker_elevation_left.value(),
            speaker_azimuth_right: default_params.speaker_azimuth_right.value(),
            speaker_elevation_right: default_params.speaker_elevation_right.value(),
            eq_enable: default_params.eq_enable.value(),
            eq_bands,
        }
    }
}

impl StandaloneConfig {
    // A special default for initializing the default params struct without infinite recursion
    fn pre_default() -> Self {
        Self {
            sofa_file_path: String::new(),
            audio_host: cpal::default_host().id().name().to_string(),
            audio_device: cpal::default_host()
                .default_output_device()
                .map(|d| d.name().unwrap_or_default())
                .unwrap_or_default(),
            master_bypass: false,
            output_gain: util::db_to_gain(0.0),
            speaker_azimuth_left: -30.0,
            speaker_elevation_left: 0.0,
            speaker_azimuth_right: 30.0,
            speaker_elevation_right: 0.0,
            eq_enable: false,
            eq_bands: (0..NUM_EQ_BANDS).map(|_| BandSetting::default()).collect(),
        }
    }
}

impl Default for OpenHeadstagePlugin {
    fn default() -> Self {
        let config = get_config_path()
            .and_then(|p| fs::read_to_string(p).ok())
            .and_then(|s| serde_json::from_str(&s).ok())
            .unwrap_or_default();

        let params = Arc::new(OpenHeadstageParams::new(config));

        Self::new(44100.0, params)
    }
}

fn get_config_path() -> Option<PathBuf> {
    let mut config_path = dirs::config_dir()?;
    config_path.push(OpenHeadstagePlugin::VENDOR);
    config_path.push(OpenHeadstagePlugin::NAME);
    fs::create_dir_all(&config_path).ok()?;
    config_path.push("open_headstage_standalone.json");
    Some(config_path)
}

impl Plugin for OpenHeadstagePlugin {
    const NAME: &'static str = "Open Headstage";
    const VENDOR: &'static str = "Open Source Community";
    const URL: &'static str = "http://example.com";
    const EMAIL: &'static str = "info@example.com";
    const VERSION: &'static str = env!("CARGO_PKG_VERSION");

    const AUDIO_IO_LAYOUTS: &'static [AudioIOLayout] = &[AudioIOLayout {
        main_input_channels: NonZeroU32::new(2),
        main_output_channels: NonZeroU32::new(2),
        ..AudioIOLayout::const_default()
    }];

    const MIDI_INPUT: MidiConfig = MidiConfig::None;
    const SAMPLE_ACCURATE_AUTOMATION: bool = true;

    type SysExMessage = ();
    type BackgroundTask = Task;

    fn params(&self) -> Arc<dyn Params> {
        self.params.clone()
    }

    fn editor(&mut self, async_executor: AsyncExecutor<Self>) -> Option<Box<dyn Editor>> {
        let params = self.params.clone();
        let headphone_index = self.headphone_index.clone();
        let database_updated = self.database_updated.clone();
        let auto_eq_result_receiver = self.auto_eq_result_receiver.clone();
        let param_change_sender = self.param_change_sender.clone();

        let editor_state = EditorState::new(
            auto_eq_result_receiver,
        );

        create_egui_editor(
            self.params.editor_state.clone(),
            (editor_state, headphone_index, database_updated, param_change_sender),
            |_, _| {},
            move |egui_ctx, setter, (state, headphone_index, database_updated, param_change_sender)| {
                egui::CentralPanel::default().show(egui_ctx, |ui| {
                    // Main controls panel
                    ui.vertical_centered(|ui| {
                        ui.heading(egui::RichText::new(Self::NAME).size(22.0));
                    });

                    ui.add_space(10.0);

                    egui::collapsing_header::CollapsingHeader::new(
                        egui::RichText::new("Master Output").size(22.0),
                    )
                    .default_open(true)
                    .show(ui, |ui| {
                        ui.label("Output Gain");
                        ui.add(widgets::ParamSlider::for_param(&params.output_gain, setter));
                    });

                    egui::collapsing_header::CollapsingHeader::new(
                        egui::RichText::new("Speaker Configuration").size(22.0),
                    )
                    .default_open(true)
                    .show(ui, |ui| {
                        ui.add(SpeakerVisualizer {
                            left_azimuth: params.speaker_azimuth_left.value(),
                            left_elevation: params.speaker_elevation_left.value(),
                            right_azimuth: params.speaker_azimuth_right.value(),
                            right_elevation: params.speaker_elevation_right.value(),
                        });
                        egui::Grid::new("speaker_grid")
                            .num_columns(2)
                            .spacing([40.0, 4.0])
                            .show(ui, |ui| {
                                ui.label("Left");
                                ui.label("Right");
                                ui.end_row();

                                ui.label("Azimuth");
                                ui.add(widgets::ParamSlider::for_param(
                                    &params.speaker_azimuth_left,
                                    setter,
                                ));
                                ui.add(widgets::ParamSlider::for_param(
                                    &params.speaker_azimuth_right,
                                    setter,
                                ));
                                ui.end_row();

                                ui.label("Elevation");
                                ui.add(widgets::ParamSlider::for_param(
                                    &params.speaker_elevation_left,
                                    setter,
                                ));
                                ui.add(widgets::ParamSlider::for_param(
                                    &params.speaker_elevation_right,
                                    setter,
                                ));
                                ui.end_row();
                            });
                    });

                    egui::collapsing_header::CollapsingHeader::new(
                        egui::RichText::new("Headphone Equalization").size(22.0),
                    )
                    .default_open(true)
                    .show(ui, |ui| {
                        ui.horizontal(|ui| {
                            if ui.button("Select SOFA File").clicked() {
                                state.file_dialog.pick_file();
                                state.file_dialog_request = Some(FileDialogRequest::Sofa);
                            }
                            if ui.button("Edit Parametric EQ").clicked() {
                                state.show_eq_editor = !state.show_eq_editor;
                            }
                        });

                        if let Some(path) = state.file_dialog.update(egui_ctx).picked() {
                            match state.file_dialog_request {
                                Some(FileDialogRequest::Sofa) => {
                                    let path_buf = path.to_path_buf();
                                    *params.sofa_file_path.write() = path_buf.to_string_lossy().to_string();
                                    async_executor.execute_background(Task::LoadSofa(path_buf));
                                }
                                None => (),
                            }
                            state.file_dialog_request = None;
                        }

                        ui.separator();

                        ui.horizontal(|ui| {
                            ui.label("AutoEQ Profile Search:");
                            if ui.button("Update Database").clicked() {
                                async_executor.execute_background(Task::UpdateHeadphoneDatabase);
                            }
                        });

                        if database_updated.swap(false, Ordering::Relaxed) {
                            nih_log!("UI: Database updated, please restart the plugin to see changes.");
                        }

                        let query_changed = ui.text_edit_singleline(&mut state.search_query).changed();
                        if query_changed {
                            state.debouncer.update();
                        }

                        if state.debouncer.ready() && !state.search_query.is_empty() {
                            let query = state.search_query.to_lowercase();
                            let mut results = headphone_index
                                .read()
                                .iter()
                                .filter(|h| h.name.to_lowercase().contains(&query))
                                .cloned()
                                .collect::<Vec<_>>();

                            // Prioritize oratory1990 results and sort alphabetically
                            results.sort_by(|a, b| {
                                let a_is_oratory = a.source == "oratory1990";
                                let b_is_oratory = b.source == "oratory1990";
                                b_is_oratory.cmp(&a_is_oratory).then_with(|| a.name.cmp(&b.name))
                            });

                            state.search_results = results.into_iter().take(100).collect();
                        } else if state.search_query.is_empty() {
                            state.search_results.clear();
                        }
                        
                        egui::ScrollArea::vertical().show(ui, |ui| {
                            for headphone in &state.search_results {
                                let display_text = format!("{} ({})", headphone.name, headphone.source);
                                if ui.button(display_text).clicked() {
                                    let result_mutex = state.auto_eq_result_receiver.clone();
                                    async_executor.execute_background(Task::LoadAutoEq(
                                        headphone.path.clone(),
                                        result_mutex,
                                    ));
                                }
                            }
                        });

                        if let Some(profile) = state.auto_eq_result_receiver.lock().take() {
                            state.loaded_eq_profile = Some(profile);
                        }

                        if let Some(profile) = &state.loaded_eq_profile {
                             if ui.button("Apply Loaded EQ").clicked() {
                                setter.begin_set_parameter(&params.preamp_gain);
                                setter.set_parameter(&params.preamp_gain, profile.preamp);
                                setter.end_set_parameter(&params.preamp_gain);

                                setter.begin_set_parameter(&params.eq_enable);
                                setter.set_parameter(&params.eq_enable, true);
                                setter.end_set_parameter(&params.eq_enable);

                                for (i, band_setting) in profile.bands.iter().enumerate() {
                                    if let Some(band_params) = params.eq_bands.get(i) {
                                        setter.begin_set_parameter(&band_params.enabled);
                                        setter.set_parameter(&band_params.enabled, band_setting.enabled);
                                        setter.end_set_parameter(&band_params.enabled);

                                        setter.begin_set_parameter(&band_params.filter_type);
                                        setter.set_parameter(&band_params.filter_type, band_setting.filter_type);
                                        setter.end_set_parameter(&band_params.filter_type);

                                        setter.begin_set_parameter(&band_params.frequency);
                                        setter.set_parameter(&band_params.frequency, band_setting.frequency);
                                        setter.end_set_parameter(&band_params.frequency);

                                        setter.begin_set_parameter(&band_params.q);
                                        setter.set_parameter(&band_params.q, band_setting.q);
                                        setter.end_set_parameter(&band_params.q);

                                        setter.begin_set_parameter(&band_params.gain);
                                        setter.set_parameter(&band_params.gain, band_setting.gain);
                                        setter.end_set_parameter(&band_params.gain);
                                    }
                                }
                                // Also send the profile to the audio thread to update coefficients
                                param_change_sender.send(ParamChange::ApplyEqProfile(profile.clone())).unwrap();
                             }
                        }
                    });
                });

                if state.show_eq_editor {
                    egui::SidePanel::right("peq_editor")
                        .resizable(true)
                        .default_width(500.0)
                        .show(egui_ctx, |ui| {
                            ui.heading("Parametric EQ");
                            ui.label("Editor placeholder");
                        });
                }
            },
        )
    }

    fn task_executor(&mut self) -> Box<dyn Fn(Self::BackgroundTask) + Send> {
        let sample_rate = self.current_sample_rate;
        let sofa_loader = self.sofa_loader.clone();
        let database_updated = self.database_updated.clone();

        Box::new(move |task| match task {
            Task::LoadSofa(path) => {
                nih_log!("BACKGROUND: Loading SOFA file from: {:?}", path);
                match MySofa::open(path.to_string_lossy().as_ref(), sample_rate) {
                    Ok(loader) => {
                        nih_log!("BACKGROUND: Successfully loaded SOFA file: {:?}", path);
                        *sofa_loader.lock() = Some(loader);
                    }
                    Err(e) => {
                        nih_log!("BACKGROUND: Failed to load SOFA file '{:?}': {:?}", path, e);
                        *sofa_loader.lock() = None;
                    }
                }
            }
            Task::LoadAutoEq(path, result_mutex) => {
                nih_log!("BACKGROUND: Loading AutoEQ profile from: {:?}", path);
                match parse_autoeq_file(&path) {
                    Ok(profile) => {
                        nih_log!(
                            "BACKGROUND: Successfully parsed AutoEQ profile from {:?}.",
                            path
                        );
                        *result_mutex.lock() = Some(profile);
                    }
                    Err(e) => {
                        nih_log!(
                            "BACKGROUND: Failed to parse AutoEQ file '{:?}': {:?}",
                            path,
                            e
                        );
                    }
                }
            }
            Task::UpdateHeadphoneDatabase => {
                nih_log!("BACKGROUND: Updating headphone database...");
                let git_pull_status = Command::new("git")
                    .arg("pull")
                    .current_dir("../PRESERVE/AutoEq")
                    .status();
                
                match git_pull_status {
                    Ok(status) if status.success() => {
                        nih_log!("BACKGROUND: Git pull successful. Re-indexing...");
                        database_updated.store(true, Ordering::Relaxed);
                    }
                    Ok(status) => {
                        nih_log!("BACKGROUND: Git pull failed with status: {}", status);
                    }
                    Err(e) => {
                        nih_log!("BACKGROUND: Failed to execute git pull: {}", e);
                    }
                }
            }
        })
    }

    fn initialize(
        &mut self,
        _audio_io_layout: &AudioIOLayout,
        buffer_config: &BufferConfig,
        _context: &mut impl InitContext<Self>,
    ) -> bool {
        self.current_sample_rate = buffer_config.sample_rate;
        true
    }

    fn reset(&mut self) {
        self.parametric_eq.reset_all_bands_state();
    }

    fn process(
        &mut self,
        buffer: &mut Buffer,
        _aux: &mut AuxiliaryBuffers,
        _context: &mut impl ProcessContext<Self>,
    ) -> ProcessStatus {
        while let Ok(change) = self.param_change_receiver.try_recv() {
            match change {
                ParamChange::ApplyEqProfile(profile) => {
                    for (i, band_setting) in profile.bands.iter().enumerate() {
                        let band_config = BandConfig {
                            filter_type: band_setting.filter_type,
                            center_freq: band_setting.frequency,
                            q: band_setting.q,
                            gain_db: band_setting.gain,
                            enabled: band_setting.enabled,
                        };
                        self.parametric_eq.update_band_coeffs(i, self.current_sample_rate, &band_config);
                    }
                }
            }
        }

        if !self.params.master_bypass.value() {
            let _az_l = self.params.speaker_azimuth_left.smoothed.next();
            let _el_l = self.params.speaker_elevation_left.smoothed.next();
            let _az_r = self.params.speaker_azimuth_right.smoothed.next();
            let _el_r = self.params.speaker_elevation_right.smoothed.next();

            let [left, right] = buffer.as_slice() else {
                return ProcessStatus::Error("Mismatched channel count");
            };

            if self.params.eq_enable.value() {
                self.parametric_eq.process_block(left, right);
            }

            let mut input_l = vec![0.0; left.len()];
            input_l.copy_from_slice(left);
            let mut input_r = vec![0.0; right.len()];
            input_r.copy_from_slice(right);

            self.convolution_engine
                .process_block(&input_l, &input_r, left, right);

            let master_gain = self.params.output_gain.smoothed.next();
            let preamp_gain = util::db_to_gain(self.params.preamp_gain.smoothed.next());
            for mut channel_samples in buffer.iter_samples() {
                for sample in channel_samples.iter_mut() {
                    *sample *= master_gain * preamp_gain;
                }
            }
        }

        ProcessStatus::Normal
    }
}

impl ClapPlugin for OpenHeadstagePlugin {
    const CLAP_ID: &'static str = "com.opensource.open-headstage";
    const CLAP_DESCRIPTION: Option<&'static str> = Some("Binaural speaker simulation plugin");
    const CLAP_MANUAL_URL: Option<&'static str> = Some("http://example.com/manual");
    const CLAP_SUPPORT_URL: Option<&'static str> = Some("http://example.com/support");
    const CLAP_FEATURES: &'static [ClapFeature] = &[ClapFeature::AudioEffect, ClapFeature::Stereo];
}

nih_export_clap!(OpenHeadstagePlugin);