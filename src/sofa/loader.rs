// src/sofa/loader.rs

use std::ffi::{CString, NulError};
// use std::path::Path; // Unused
// use std::sync::Arc; // Unused

// This will include the bindings generated by `bindgen` from `build.rs`
#[allow(warnings)]
mod bindings {
    include!(concat!(env!("OUT_DIR"), "/mysofa_bindings.rs"));
}

// Define MYSOFA_OK manually if not correctly picked up by bindgen
const MYSOFA_OK: ::std::os::raw::c_int = 0; // Explicitly use c_int type from std

#[derive(Debug)]
pub enum SofaError {
    NulError(NulError),
    FileOpenError(String),
    MysofaError(String), // For errors reported by libmysofa functions
    MysofaFilterError(String), // For errors from mysofa_getfilter_float
    // Add other specific errors as needed
}

impl From<NulError> for SofaError {
    fn from(err: NulError) -> Self {
        SofaError::NulError(err)
    }
}

/// A safe wrapper around the `*mut bindings::MYSOFA_EASY` handle.
pub struct MySofa {
    handle: *mut bindings::MYSOFA_EASY,
    pub filter_length: usize, // HRIR length after resampling by mysofa_open
    pub source_samplerate: f32, // Samplerate of the SOFA file before any resampling
    pub resampled_samplerate: f32, // Samplerate after mysofa_open (should match target_samplerate)
}

// libmysofa is not thread-safe for concurrent operations on the same handle.
// However, if a MySofa instance is owned by the plugin's main struct and only
// accessed by the audio thread (or access is properly synchronized), Send could be okay.
// Sync is more problematic if multiple threads try to call methods on it concurrently.
// For typical plugin usage (init on main, process on audio), Send might be acceptable.
// Let's assume it's used in a way that ensures safe access (e.g. not concurrently modified).
unsafe impl Send for MySofa {}
// Unsafe impl Sync for MySofa {} // Probably not safe to mark as Sync without external locking.

impl Drop for MySofa {
    fn drop(&mut self) {
        if !self.handle.is_null() {
            unsafe {
                bindings::mysofa_close(self.handle);
            }
            self.handle = std::ptr::null_mut();
        }
    }
}

impl MySofa {
    /// Opens a SOFA file and prepares it for HRIR retrieval.
    /// `libmysofa`'s `mysofa_open` handles resampling to `target_samplerate`.
    pub fn open(filepath: &str, target_samplerate: f32) -> Result<Self, SofaError> {
        let c_filepath = CString::new(filepath)?;

        let mut err_code_open = MYSOFA_OK; // Use manually defined MYSOFA_OK
        let handle = unsafe {
            bindings::mysofa_open(
                c_filepath.as_ptr(),
                target_samplerate,
                &mut 0, // filter_length (output, will be updated by mysofa_open if it's designed to)
                &mut err_code_open,
            )
        };

        if err_code_open != MYSOFA_OK || handle.is_null() {
            // It's useful to get a more descriptive error if possible.
            // libmysofa doesn't have a direct error string function for mysofa_open errors.
            // We'll return a generic one based on the error code.
            return Err(SofaError::FileOpenError(format!(
                "Failed to open SOFA file '{}'. Mysofa error code: {}",
                filepath, err_code_open
            )));
        }

        // Access N via hrtf. For sampleRate, access DataSamplingRate.values[0].
        let filter_length = unsafe { (*(*handle).hrtf).N } as usize;
        let source_samplerate = unsafe {
            // (*handle).hrtf is *mut MYSOFA_HRTF
            // (*(*handle).hrtf).DataSamplingRate is MYSOFA_ARRAY (not a pointer)
            let data_sampling_rate_array = (*(*handle).hrtf).DataSamplingRate;
            if data_sampling_rate_array.values.is_null() {
                 // This check might be problematic if .values itself is not guaranteed
                 // to be non-null even if elements > 0, but it's a start.
                 // Or, if elements == 0, then values might be null or invalid.
                 // A robust check would involve data_sampling_rate_array.elements.
                 return Err(SofaError::MysofaError("DataSamplingRate values pointer is null.".to_string()));
            }
            // data_sampling_rate_array.values is *mut f32 as per bindgen output in last error
            data_sampling_rate_array.values.read()
        };
        // mysofa_open resamples, so the effective sample rate of the filters should be target_samplerate.
        // We can double check this with mysofa_get_sampling_rate if needed, but it would apply to the raw file.
        // The HRIRs obtained from mysofa_getfilter_float will be at target_samplerate.

        Ok(Self {
            handle,
            filter_length,
            source_samplerate,
            resampled_samplerate: target_samplerate, // Assuming mysofa_open succeeded in resampling
        })
    }

    /// Retrieves the HRIR pair for a given source position (azimuth, elevation, radius).
    /// Coordinates are in degrees for azimuth/elevation, meters for radius.
    /// libmysofa expects source position in Cartesian coordinates (X, Y, Z).
    /// Y is up, Z is front, X is left (standard AES69).
    pub fn get_hrtf_irs(
        &self,
        azimuth_deg: f32,
        elevation_deg: f32,
        radius_m: f32,
    ) -> Result<(Vec<f32>, Vec<f32>), SofaError> {
        if self.handle.is_null() {
            return Err(SofaError::MysofaError("MySofa handle is not initialized.".to_string()));
        }
        if self.filter_length == 0 {
             return Err(SofaError::MysofaError("Filter length is zero.".to_string()));
        }

        // Convert spherical (AES69 convention: azimuth, elevation, radius) to Cartesian (X,Y,Z for mysofa)
        // Azimuth: 0 deg front, positive to the left.
        // Elevation: 0 deg horizontal, positive upwards.
        // Radius: distance from origin.

        // mysofa_s2c expects: azimuth (rad), elevation (rad), radius
        // It modifies the input array in place.
        let mut cartesian_coords = [
            azimuth_deg.to_radians(),
            elevation_deg.to_radians(),
            radius_m,
        ];
        unsafe {
            bindings::mysofa_s2c(&mut cartesian_coords[0] as *mut f32);
        }
        // cartesian_coords now holds [x, y, z]

        let mut left_ir_buffer = vec![0.0f32; self.filter_length];
        let mut right_ir_buffer = vec![0.0f32; self.filter_length];
        let mut delay_left_s = 0.0f32; // Delay in seconds
        let mut delay_right_s = 0.0f32;

        let err_code_filter = unsafe {
            bindings::mysofa_getfilter_float(
                self.handle,
                cartesian_coords[0], // x
                cartesian_coords[1], // y
                cartesian_coords[2], // z
                left_ir_buffer.as_mut_ptr(),
                right_ir_buffer.as_mut_ptr(),
                &mut delay_left_s,
                &mut delay_right_s,
            )
        };

        if err_code_filter != MYSOFA_OK {
            // Check the error field in the handle for more details if available,
            // though the primary error signal is the return code.
            let mut detail_err_code = 0; // Default if not accessible
            if !self.handle.is_null() {
                // This assumes `err` field is accessible and correctly generated by bindgen.
                // If not, this part might need adjustment or conditional compilation.
                // For now, let's try to access it, assuming the previous subtask's
                // findings about allowlisting MYSOFA_EASY are sufficient.
                detail_err_code = unsafe { (*self.handle).err };
            }
            return Err(SofaError::MysofaFilterError(format!(
                "mysofa_getfilter_float failed with code: {}. Handle error field: {}",
                err_code_filter, detail_err_code
            )));
        }

        // TODO: Handle delays (delay_left_s, delay_right_s) if necessary.
        // For now, we return the full IRs. The delays might be part of the IRs
        // or might need separate compensation depending on convolution strategy.
        // The ConvolutionEngine currently takes the IR as is.

        Ok((left_ir_buffer, right_ir_buffer))
    }

    /// Helper to convert spherical coordinates (degrees, radius) to Cartesian.
    /// Input: [azimuth_deg, elevation_deg, radius_m]
    /// Output: [x, y, z] (AES69: Y up, Z front, X left)
    pub fn spherical_to_cartesian(spherical: &[f32; 3]) -> [f32; 3] {
        let mut cartesian = [
            spherical[0].to_radians(), // azimuth to radians
            spherical[1].to_radians(), // elevation to radians
            spherical[2],              // radius
        ];
        unsafe {
            bindings::mysofa_s2c(&mut cartesian[0] as *mut f32);
        }
        cartesian // now [x,y,z]
    }

    /// Helper to convert Cartesian coordinates to spherical (degrees, radius).
    /// Input: [x, y, z] (AES69)
    /// Output: [azimuth_deg, elevation_deg, radius_m]
    pub fn cartesian_to_spherical(cartesian: &[f32; 3]) -> [f32; 3] {
        let mut spherical = *cartesian; // copy
        unsafe {
            bindings::mysofa_c2s(&mut spherical[0] as *mut f32);
        }
        // spherical now [azimuth_rad, elevation_rad, radius_m]
        [
            spherical[0].to_degrees(), // azimuth to degrees
            spherical[1].to_degrees(), // elevation to degrees
            spherical[2],              // radius
        ]
    }
}

// Basic tests (more comprehensive tests would require a SOFA file and proper mocking or integration)
#[cfg(test)]
mod tests {
    use super::*;
    use std::path::Path;

    // A dummy SOFA file path for testing.
    // In a real test environment, this should point to an actual minimal SOFA file.
    // For CI, we might need to conditionally skip this test or provide a file.
    const TEST_SOFA_PATH: &str = "assets/test.sofa"; // Placeholder

    #[test]
    fn test_open_non_existent_file() {
        // Use a more specific non-existent path for this test
        match MySofa::open("/tmp/some_hopefully_non_existent_sofa_file_for_test.sofa", 48000.0) {
            Err(SofaError::FileOpenError(_)) => {
                // Expected error
            }
            Ok(_) => panic!("Should not succeed in opening a non-existent file."),
            Err(e) => panic!("Unexpected error type: {:?}", e),
        }
    }

    #[test]
    fn test_get_hrtf_irs_error_handling() {
        // This test attempts to trigger an error in mysofa_getfilter_float.
        // It requires a valid SOFA file to open successfully first.
        // If TEST_SOFA_PATH doesn't exist, this test will likely fail at the open() call,
        // which is acceptable as we can't easily add test files in this environment.
        // The main purpose is to check the error handling logic if get_hrtf_irs is reached.

        // Check if the placeholder SOFA file exists. If not, we can't proceed to test get_hrtf_irs error.
        // In a real CI, we'd download or ensure this file exists. Here, we'll just print a notice.
        if !Path::new(TEST_SOFA_PATH).exists() {
            eprintln!(
                "Test SOFA file '{}' not found. Skipping HRTF filter error test logic. \
                 This test primarily validates the error path if mysofa_getfilter_float fails.",
                 TEST_SOFA_PATH
            );
            // We can still proceed with a dummy MySofa if open fails in a specific way,
            // but the MySofa::open itself will likely fail with FileOpenError first.
            // Let's try to open and if it fails, that's the test outcome for now.
        }

        match MySofa::open(TEST_SOFA_PATH, 48000.0) {
            Ok(mysofa) => {
                // Try to get HRIRs with parameters that might be invalid (e.g., radius 0)
                // libmysofa documentation suggests that positions exactly at (0,0,0)
                // or outside the measured range can lead to errors from mysofa_getfilter_float.
                let result = mysofa.get_hrtf_irs(0.0, 0.0, 0.0); // Azimuth, Elevation, Radius (0)

                match result {
                    Err(SofaError::MysofaFilterError(_)) => {
                        // This is the expected error type if mysofa_getfilter_float fails.
                        // The error message content (error code) might vary.
                        println!("Successfully caught MysofaFilterError as expected.");
                    }
                    Ok(_) => {
                        panic!("mysofa_getfilter_float did not return an error for potentially invalid parameters (radius 0.0). This might indicate the specific SOFA file handles this case gracefully, or the error condition wasn't triggered as expected.");
                    }
                    Err(e) => {
                        panic!("Expected MysofaFilterError, but got a different error: {:?}", e);
                    }
                }
            }
            Err(SofaError::FileOpenError(_)) => {
                // This is an expected outcome if the TEST_SOFA_PATH file doesn't exist.
                // The test then implicitly doesn't reach the get_hrtf_irs error check.
                eprintln!(
                    "Could not open test SOFA file '{}'. The test for get_hrtf_irs error handling was not fully executed.",
                    TEST_SOFA_PATH
                );
                // Depending on strictness, this could be a panic or just an accepted state.
                // For now, we accept it as this environment doesn't guarantee the file.
            }
            Err(e) => {
                panic!("Failed to open test SOFA file with an unexpected error: {:?}", e);
            }
        }
    }

    // A very basic test for coordinate conversion round trip, assuming mysofa C functions are correct.
    // This is more of a sanity check for the wrapper.
    #[test]
    fn test_coordinate_conversion_roundtrip() {
        let spherical_in: [f32; 3] = [30.0, 15.0, 1.5]; // Az=30deg, El=15deg, R=1.5m
        let cartesian = MySofa::spherical_to_cartesian(&spherical_in);
        let spherical_out = MySofa::cartesian_to_spherical(&cartesian);

        const TOLERANCE: f32 = 1e-4; // Radians to/from degrees can have small errors
        assert!((spherical_in[0] - spherical_out[0]).abs() < TOLERANCE, "Azimuth mismatch");
        assert!((spherical_in[1] - spherical_out[1]).abs() < TOLERANCE, "Elevation mismatch");
        assert!((spherical_in[2] - spherical_out[2]).abs() < TOLERANCE, "Radius mismatch");
    }
}
