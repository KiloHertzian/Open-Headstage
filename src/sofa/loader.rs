// src/sofa/loader.rs

use std::ffi::{CString, NulError};
// use std::path::Path; // Unused
// use std::sync::Arc; // Unused

// This will include the bindings generated by `bindgen` from `build.rs`
#[allow(warnings)]
mod bindings {
    include!(concat!(env!("OUT_DIR"), "/mysofa_bindings.rs"));
}

// Define MYSOFA_OK manually if not correctly picked up by bindgen
const MYSOFA_OK: ::std::os::raw::c_int = 0; // Explicitly use c_int type from std

#[derive(Debug)]
pub enum SofaError {
    NulError(NulError),
    FileOpenError(String),
    MysofaError(String), // For errors reported by libmysofa functions
    // Add other specific errors as needed
}

impl From<NulError> for SofaError {
    fn from(err: NulError) -> Self {
        SofaError::NulError(err)
    }
}

/// A safe wrapper around the `*mut bindings::MYSOFA_EASY` handle.
pub struct MySofa {
    handle: *mut bindings::MYSOFA_EASY,
    pub filter_length: usize, // HRIR length after resampling by mysofa_open
    pub source_samplerate: f32, // Samplerate of the SOFA file before any resampling
    pub resampled_samplerate: f32, // Samplerate after mysofa_open (should match target_samplerate)
}

// libmysofa is not thread-safe for concurrent operations on the same handle.
// However, if a MySofa instance is owned by the plugin's main struct and only
// accessed by the audio thread (or access is properly synchronized), Send could be okay.
// Sync is more problematic if multiple threads try to call methods on it concurrently.
// For typical plugin usage (init on main, process on audio), Send might be acceptable.
// Let's assume it's used in a way that ensures safe access (e.g. not concurrently modified).
unsafe impl Send for MySofa {}
// Unsafe impl Sync for MySofa {} // Probably not safe to mark as Sync without external locking.

impl Drop for MySofa {
    fn drop(&mut self) {
        if !self.handle.is_null() {
            unsafe {
                bindings::mysofa_close(self.handle);
            }
            self.handle = std::ptr::null_mut();
        }
    }
}

impl MySofa {
    /// Opens a SOFA file and prepares it for HRIR retrieval.
    /// `libmysofa`'s `mysofa_open` handles resampling to `target_samplerate`.
    pub fn open(filepath: &str, target_samplerate: f32) -> Result<Self, SofaError> {
        let c_filepath = CString::new(filepath)?;

        let mut err_code_open = MYSOFA_OK; // Use manually defined MYSOFA_OK
        let handle = unsafe {
            bindings::mysofa_open(
                c_filepath.as_ptr(),
                target_samplerate,
                &mut 0, // filter_length (output, will be updated by mysofa_open if it's designed to)
                &mut err_code_open,
            )
        };

        if err_code_open != MYSOFA_OK || handle.is_null() {
            // It's useful to get a more descriptive error if possible.
            // libmysofa doesn't have a direct error string function for mysofa_open errors.
            // We'll return a generic one based on the error code.
            return Err(SofaError::FileOpenError(format!(
                "Failed to open SOFA file '{}'. Mysofa error code: {}",
                filepath, err_code_open
            )));
        }

        // Access N via hrtf. For sampleRate, access DataSamplingRate.values[0].
        let filter_length = unsafe { (*(*handle).hrtf).N } as usize;
        let source_samplerate = unsafe {
            // (*handle).hrtf is *mut MYSOFA_HRTF
            // (*(*handle).hrtf).DataSamplingRate is MYSOFA_ARRAY (not a pointer)
            let data_sampling_rate_array = (*(*handle).hrtf).DataSamplingRate;
            if data_sampling_rate_array.values.is_null() {
                 // This check might be problematic if .values itself is not guaranteed
                 // to be non-null even if elements > 0, but it's a start.
                 // Or, if elements == 0, then values might be null or invalid.
                 // A robust check would involve data_sampling_rate_array.elements.
                 return Err(SofaError::MysofaError("DataSamplingRate values pointer is null.".to_string()));
            }
            // data_sampling_rate_array.values is *mut f32 as per bindgen output in last error
            data_sampling_rate_array.values.read()
        };
        // mysofa_open resamples, so the effective sample rate of the filters should be target_samplerate.
        // We can double check this with mysofa_get_sampling_rate if needed, but it would apply to the raw file.
        // The HRIRs obtained from mysofa_getfilter_float will be at target_samplerate.

        Ok(Self {
            handle,
            filter_length,
            source_samplerate,
            resampled_samplerate: target_samplerate, // Assuming mysofa_open succeeded in resampling
        })
    }

    /// Retrieves the HRIR pair for a given source position (azimuth, elevation, radius).
    /// Coordinates are in degrees for azimuth/elevation, meters for radius.
    /// libmysofa expects source position in Cartesian coordinates (X, Y, Z).
    /// Y is up, Z is front, X is left (standard AES69).
    pub fn get_hrtf_irs(
        &self,
        azimuth_deg: f32,
        elevation_deg: f32,
        radius_m: f32,
    ) -> Result<(Vec<f32>, Vec<f32>), SofaError> {
        if self.handle.is_null() {
            return Err(SofaError::MysofaError("MySofa handle is not initialized.".to_string()));
        }
        if self.filter_length == 0 {
             return Err(SofaError::MysofaError("Filter length is zero.".to_string()));
        }

        // Convert spherical (AES69 convention: azimuth, elevation, radius) to Cartesian (X,Y,Z for mysofa)
        // Azimuth: 0 deg front, positive to the left.
        // Elevation: 0 deg horizontal, positive upwards.
        // Radius: distance from origin.

        // mysofa_s2c expects: azimuth (rad), elevation (rad), radius
        // It modifies the input array in place.
        let mut cartesian_coords = [
            azimuth_deg.to_radians(),
            elevation_deg.to_radians(),
            radius_m,
        ];
        unsafe {
            bindings::mysofa_s2c(&mut cartesian_coords[0] as *mut f32);
        }
        // cartesian_coords now holds [x, y, z]

        let mut left_ir_buffer = vec![0.0f32; self.filter_length];
        let mut right_ir_buffer = vec![0.0f32; self.filter_length];
        let mut delay_left_s = 0.0f32; // Delay in seconds
        let mut delay_right_s = 0.0f32;

        // Call the function. Error checking is temporarily removed for diagnostics.
        unsafe {
            bindings::mysofa_getfilter_float(
                self.handle,
                cartesian_coords[0], // x
                cartesian_coords[1], // y
                cartesian_coords[2], // z
                left_ir_buffer.as_mut_ptr(),
                right_ir_buffer.as_mut_ptr(),
                &mut delay_left_s,
                &mut delay_right_s,
            );
        }

        // TODO: CRITICAL - Error checking for mysofa_getfilter_float is currently missing.
        // The Rust binding for mysofa_getfilter_float appears to return `()` (void),
        // and the `error` field of the MYSOFA_EASY handle is not accessible with current bindings.
        // This needs to be resolved for robust error handling, possibly by:
        // 1. Fixing bindgen setup to correctly parse MYSOFA_EASY and expose `error` field.
        // 2. Fixing bindgen setup to correctly get the `int` return type of `mysofa_getfilter_float`.

        // TODO: Handle delays (delay_left_s, delay_right_s) if necessary.
        // For now, we return the full IRs. The delays might be part of the IRs
        // or might need separate compensation depending on convolution strategy.
        // The ConvolutionEngine currently takes the IR as is.

        Ok((left_ir_buffer, right_ir_buffer))
    }

    /// Helper to convert spherical coordinates (degrees, radius) to Cartesian.
    /// Input: [azimuth_deg, elevation_deg, radius_m]
    /// Output: [x, y, z] (AES69: Y up, Z front, X left)
    pub fn spherical_to_cartesian(spherical: &[f32; 3]) -> [f32; 3] {
        let mut cartesian = [
            spherical[0].to_radians(), // azimuth to radians
            spherical[1].to_radians(), // elevation to radians
            spherical[2],              // radius
        ];
        unsafe {
            bindings::mysofa_s2c(&mut cartesian[0] as *mut f32);
        }
        cartesian // now [x,y,z]
    }

    /// Helper to convert Cartesian coordinates to spherical (degrees, radius).
    /// Input: [x, y, z] (AES69)
    /// Output: [azimuth_deg, elevation_deg, radius_m]
    pub fn cartesian_to_spherical(cartesian: &[f32; 3]) -> [f32; 3] {
        let mut spherical = *cartesian; // copy
        unsafe {
            bindings::mysofa_c2s(&mut spherical[0] as *mut f32);
        }
        // spherical now [azimuth_rad, elevation_rad, radius_m]
        [
            spherical[0].to_degrees(), // azimuth to degrees
            spherical[1].to_degrees(), // elevation to degrees
            spherical[2],              // radius
        ]
    }
}

// Basic tests (more comprehensive tests would require a SOFA file and proper mocking or integration)
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_open_non_existent_file() {
        match MySofa::open("/tmp/non_existent_sofa_file.sofa", 48000.0) {
            Err(SofaError::FileOpenError(_)) => {
                // Expected error
            }
            Ok(_) => panic!("Should not succeed in opening a non-existent file."),
            Err(e) => panic!("Unexpected error type: {:?}", e),
        }
    }

    // A very basic test for coordinate conversion round trip, assuming mysofa C functions are correct.
    // This is more of a sanity check for the wrapper.
    #[test]
    fn test_coordinate_conversion_roundtrip() {
        let spherical_in: [f32; 3] = [30.0, 15.0, 1.5]; // Az=30deg, El=15deg, R=1.5m
        let cartesian = MySofa::spherical_to_cartesian(&spherical_in);
        let spherical_out = MySofa::cartesian_to_spherical(&cartesian);

        const TOLERANCE: f32 = 1e-4; // Radians to/from degrees can have small errors
        assert!((spherical_in[0] - spherical_out[0]).abs() < TOLERANCE, "Azimuth mismatch");
        assert!((spherical_in[1] - spherical_out[1]).abs() < TOLERANCE, "Elevation mismatch");
        assert!((spherical_in[2] - spherical_out[2]).abs() < TOLERANCE, "Radius mismatch");
    }
}
